<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Elaine&#39;s Notebook</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-25T05:11:47.550Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Elaine</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FTTM中的软件Bug</title>
    <link href="http://yoursite.com/2018/05/25/tip/tip-ftld-bug/"/>
    <id>http://yoursite.com/2018/05/25/tip/tip-ftld-bug/</id>
    <published>2018-05-25T04:42:56.000Z</published>
    <updated>2018-05-25T05:11:47.550Z</updated>
    
    <content type="html"><![CDATA[<p>在使用FactoryTalk Transaction Manager过程中，有时会遇到双击配置Live Data Connector时整个程序没有响应的情况，排除可能的问题包括：</p><ol><li>两个Configuration中重名的Connector</li><li>选择不存在的FactoryTalk View SE程序</li><li>打开FactoryTalk View SE服务器和客户端的顺序</li><li>Kepserver OPC服务器安装</li><li>硬盘剩余容量小</li></ol><p>这些情况都不会造成软件崩溃。<br>在一次尝试中意外复现了该问题，证明如下操作会造成Live Data Connector无法配置：<br>对于一个未绑定FactoryTalk View SE程序的Live Data Connector，双击初次配置并选择程序的过程中<strong>不可以</strong>选择“Cancel取消”，<strong>可以</strong>任意选择一个程序后在导入标签的页面选择“Close关闭”，否则FactoryTalk Transaction Manager会立即崩溃，再次打开可以启动自身或其他Configuration中的服务，但无法更改任何Live Data Connector的配置。</p><p>软件版本：<br>Windows Server 2008 R2<br>FactoryTalk Service Platform 2.74.00 (CPR9 SR7.4)<br>FactoryTalk Transaction Manager 10.10.00</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用FactoryTalk Transaction Manager过程中，有时会遇到双击配置Live Data Connector时整个程序没有响应的情况，排除可能的问题包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两个Configuration中重名的Connector&lt;/li&gt;

      
    
    </summary>
    
      <category term="tip" scheme="http://yoursite.com/categories/tip/"/>
    
    
      <category term="FactoryTalk" scheme="http://yoursite.com/tags/FactoryTalk/"/>
    
      <category term="Rockwell" scheme="http://yoursite.com/tags/Rockwell/"/>
    
      <category term="Transaction Manager" scheme="http://yoursite.com/tags/Transaction-Manager/"/>
    
  </entry>
  
  <entry>
    <title>《工业控制网络》笔记</title>
    <link href="http://yoursite.com/2018/05/25/note/note-industrial/"/>
    <id>http://yoursite.com/2018/05/25/note/note-industrial/</id>
    <published>2018-05-25T04:41:39.000Z</published>
    <updated>2018-05-29T06:35:07.086Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《工业控制网络》 主编：王振力 人民邮电出版社 2012年1月第1版 TP273 ISBN: 978-7-115-30136-9 </strong><br>本书介绍了工业控制网络的特点、发展历程、技术现状和发展趋势，重点介绍了Modbus、Profibus、CAN、DeviceNet及CANopen等现场总线技术，还介绍了EAP、Profinet、HSE、EtherNet/IP及Modbus-TCP等工业以太网技术，并结合台达工业自动化产品有针对性地安排了大量工业控制网络应用案例和实验内容。<br><a id="more"></a></p><!-- toc --><ul><li><a href="#第一章-绪论">第一章 绪论</a><ul><li><a href="#11-工业自动控制系统历史">1.1 工业自动控制系统历史</a></li><li><a href="#12-工业控制网络特点">1.2 工业控制网络特点</a></li><li><a href="#13-传统控制网络现场总线">1.3 传统控制网络：现场总线</a></li><li><a href="#14-现代控制网络工业以太网">1.4 现代控制网络：工业以太网</a></li><li><a href="#16-工业控制网络发展趋势">1.6 工业控制网络发展趋势</a></li></ul></li><li><a href="#第二章-数据通信与网络基础">第二章 数据通信与网络基础</a><ul><li><a href="#21-数据通信系统概述">2.1 数据通信系统概述</a></li></ul></li></ul><!-- tocstop --><h2><span id="第一章-绪论">第一章 绪论</span></h2><h3><span id="11-工业自动控制系统历史">1.1 工业自动控制系统历史</span></h3><p>20世纪50年代前 - <strong>模拟仪表控制系统(Analog Control System, ACS)</strong>：精度低、干扰大<br>20世纪60年代起 - <strong>直接数字控制系统(Direct Digital Control, DDC)</strong>：中心计算机可靠性差<br>20世纪70年代起 - <strong>集散式控制系统(Distributed Control System, DCS)</strong>：电缆多、互操作性差<br>20世纪90年代起 - <strong>现场总线控制系统(Fieldbus Control System, FCS)</strong>：成本低、通信可靠</p><h3><span id="12-工业控制网络特点">1.2 工业控制网络特点</span></h3><p>工业控制网络是3C技术(Computer,Communication,Control)发展汇集成的结合点，是信息技术、数字化、智能化网络发展到现场的结果，是一类特殊的网络，与传统信息网络相比有如下特点：</p><ol><li>应用于工业现场，对环境要求高</li><li>包含多种复杂、异构的节点，多为嵌入式CPU</li><li>主要任务为传输工业数据、承担自动测控任务，实时性要求高</li></ol><h3><span id="13-传统控制网络现场总线">1.3 传统控制网络：现场总线</span></h3><p>现场总线技术源于欧洲，目前以欧美日地区最为发达，经过近20年的竞争和完善，目前较有生命力的有10多种，并仍处于激烈的市场竞争中。诞生于不同领域的总线技术往往对特定领域的适用性较好，如Profibus较适合工厂自动化、CAN适合汽车工业、FF适用于过程控制、LonWorks适用于楼宇自动化等。</p><h3><span id="14-现代控制网络工业以太网">1.4 现代控制网络：工业以太网</span></h3><p>工业以太网是在以太网技术和TCP/IP技术的基础上发展起来的一种工业控制网络。由于现场总线多种标准并存，异种网络通信困难，以太网进入工业自动化领域并快速发展。<br>以太网是在1972年发明的，并于1982年公布了以太网规范，IEEE802.3就是以这个技术规范为基础制定的。以太网技术具有成本低、通信速率和带宽高、兼容性好、软硬件资源丰富等诸多优点。<br>将工业以太网引入工业控制领域，主要有以下优点：</p><ol><li>采用TCP/IP国际标准，协议开放，互连和互操作性强</li><li>可实现远程访问和诊断</li><li>网络速度快，不同传输介质可以灵活组合</li><li>指出冗余连接配置，数据可达性强</li><li>成熟可靠的系统安全体系</li></ol><p>同时工业以太网也存在实时性、可靠性、安全性、总线供电等问题。</p><h3><span id="16-工业控制网络发展趋势">1.6 工业控制网络发展趋势</span></h3><p>纵观当今工业控制网络的发展趋势和市场需求，未来工业控制网络发展方向包括：</p><ol><li>提高通信的实时性：操作系统和交换技术的实时性</li><li>提高通信的可靠性：虚拟自动化网络</li><li>提高通信的安全性：黑通道机制和安全完整性等级SIL</li><li>多现场总线集成：<a href="/2018/05/17/knowledge/know-opc/" title="OPC及OPC UA技术">OPC及OPC UA技术</a></li><li>无线网络技术应用：工业WLAN协议(IEEE802.11n)、蓝牙(IEEE 802.15.1)和ZigBee(IEEE 802.15.4)</li></ol><h2><span id="第二章-数据通信与网络基础">第二章 数据通信与网络基础</span></h2><h3><span id="21-数据通信系统概述">2.1 数据通信系统概述</span></h3><p><strong>数据通信</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;《工业控制网络》 主编：王振力 人民邮电出版社 2012年1月第1版 TP273 ISBN: 978-7-115-30136-9 &lt;/strong&gt;&lt;br&gt;本书介绍了工业控制网络的特点、发展历程、技术现状和发展趋势，重点介绍了Modbus、Profibus、CAN、DeviceNet及CANopen等现场总线技术，还介绍了EAP、Profinet、HSE、EtherNet/IP及Modbus-TCP等工业以太网技术，并结合台达工业自动化产品有针对性地安排了大量工业控制网络应用案例和实验内容。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="note" scheme="http://yoursite.com/categories/note/"/>
    
    
      <category term="communication basis" scheme="http://yoursite.com/tags/communication-basis/"/>
    
      <category term="industrial control" scheme="http://yoursite.com/tags/industrial-control/"/>
    
  </entry>
  
  <entry>
    <title>OPC及OPC UA技术</title>
    <link href="http://yoursite.com/2018/05/17/knowledge/know-opc/"/>
    <id>http://yoursite.com/2018/05/17/knowledge/know-opc/</id>
    <published>2018-05-17T07:11:12.000Z</published>
    <updated>2018-05-29T06:29:01.789Z</updated>
    
    <content type="html"><![CDATA[<p>OPC是一个工业标准，属于<a href="https://opcfoundation.org/" target="_blank" rel="noopener">OPC基金会</a>，现有会员已超过220家，包括世界上所有主要的自动化控制系统、仪器仪表及过程控制系统的公司。</p><p>经典OPC规范基于微软Windows系统提供的COM/DCOM技术，用于软件之间数据交换的规范。OPC规范定义了几种不同的，用于访问过程数据、报警信息以及历史数据的版本规范：<br>OPC实时数据访问规范（OPC DA）定义了包括数据值，更新时间与数据品质信息的相关标准。<br>OPC历史数据访问规范（OPC HDA）定义了查询、分析历史数据和含有时标的数据的方法。<br>OPC报警事件访问规范（OPC AE）定义了报警与时间类型的消息类信息，以及状态变化管理等相关标准。</p><p>基于COM/DCOM的技术有着不可根除的缺点，因此随着技术的进步，以及数据交换各方面需求的提高，OPC基金会在2008年发布了新的规范：OPC UA。</p><p>OPC UA规范不再是基于COM/DCOM技术，因此OPC UA不仅能在Windows平台上实现，更可以在Linux，以及其他的嵌入式平台中实现。与传统OPC规范相同，OPC UA 同样有着相同的设计目标：</p><ol><li>功能等价：所有的基于COM的OPC规范中的功能，都映射到了OPC UA中。</li><li>多平台支持：支持从嵌入式的微控制器到基于云的分散式控制架构。</li><li>安全：信息加密，互访认证以及安全监听功能。</li><li>扩展性：不影响现有应用程序的情况下，就可以添加新的功能。</li><li>丰富的信息建模：可定义复杂的信息，而不再是单一的数据。</li></ol><p>相比于传统OPC，OPC UA具有以下特点：<br>一、功能方面，OPC UA不仅支持传统OPC的所有功能，更支持更多新的功能：1. 网络发现：自动查询本PC机中与当前网络中可用的OPC Server。2. 地址空间优化：所有的数据都可以分级结构定义，使得OPC Client不仅能够读取并利用简单数据，也能访问复杂的结构体。3. 互访认证：所有的读写数据/消息行为，都必须有访问许可。4. 数据订阅：针对OPCClient不同的配置与标准，提供数据/消息的监控，以及数值变化时的变化报告。5. 方案(Methods)功能：OPC UA中定义了通过在OPCServer中定义方案（Methods），来让OPC client执行特定的程序。<br>二、平台支持方面，由于不再基于COM/DCOM技术，OPC UA标准提供的更多的可支持的硬件或软件平台。硬件平台诸如传统的PC机、基于云的服务器、PLC、ARM等其他微处理器；而软件平台可支持微软的Windows、苹果公司的OSX、安卓，以及其他的基于Linux的分布式操作系统。<br>三、安全性方面，最大的变化是OPC UA可以通过任何单一端口（经管理员开放后）进行通信，这使得OPC通信不再会由于防火墙受到大量的限制</p><p>1、OPC UA在传输中可通过XML格式或者二进制格式来传输，并且可选择并兼容更多通用的IT通信协议，比如HTTPS。同时，在加密时，也能达到128或者256位的加密深度。在客户端与服务器的通信许可方面，OPC UA使用了OpenSSL许可证来规定哪些应用程序或系统可以使用OPC与另一端相连接。2、在建模方面，OPC UA将建模的架构由“数据建模”扩展为了“信息建模”。OPC UA规范中不仅仅提供了完整的面向对象的数据建模，同时也可定义复杂的多级结构体。数据类型或结构体都在配置文件（profiles）中定义，不仅可以定义已存在的传统OPC规范中的类型，还可以扩展加入其他的供应商或组织定义的新类型。</p><p><a href="http://blog.sina.com.cn/s/blog_a68809ea0102vk1p.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_a68809ea0102vk1p.html</a></p><p>【1. OPC UA 规范组成】</p><p>OPC统一体系架构规范由十一部分组成。各部分规范概要介绍如下：</p><p>第一部分——概念<br>这部分规范描述了关于OPC UA 服务器和客户端的基本概念。</p><p>第二部分——安全模型<br>这部分规范描述了用于OPC UA客户端和OPC UA服务器之间安全交互的模型。</p><p>第三部分——地址空间模型<br>这部分规范描述了服务器地址空间的内容和结构。</p><p>第四部分——服务<br>这部分规范指定了OPC UA服务器提供的所有服务。</p><p>第五部分——信息模型<br>详细说明了为OPC UA服务器定义的标准数据类型和它们之间的关系。</p><p>第六部分——映射<br>这部分规范详细说明了OPC UA支持的传输映射和数据编码机制。</p><p>第七部分——协议<br>这部分规范详细说明了可用于OPC客户端和服务器的协议。这些协议提供了可用于一致性标准的服务和功能。服务器和客户端可依靠这些协议来进行测试。</p><p>第八部分——数据访问<br>详细说明了如何使用OPC UA进行数据访问。</p><p>第九部分——报警与事件<br>详细说明了使用OPC UA对报警与条件通道的支持。基本的系统包括对简单事件的支持；这部分规范拓展了对报警与事件的支持。</p><p>第十部分——程序<br>详细说明了OPC UA对程序访问的支持。</p><p>第十一部分——历史数据访问<br>详细说明了使用OPC UA对历史信息的访问。访问包括对历史数据和历史事件的访问。</p><p>【2. OPC UA 规范总貌】</p><p>2.1 介绍<br>    OPC统一体系结构是一个不依赖任何平台的标准，借助此标准各种各样的系统和设备能在不同的网络中以C/S的模式进行通信。OPC统一体系结构通过确认客户端和服务器的身份和自动抵御攻击来支持稳定的、安全的通信。OPC UA定义了一系列服务器所能提供的服务，特定的服务器需要向客户端详细说明它们所支持的服务。信息通过使用标准的和宿主程序定义的数据类型进行表达。服务器定义客户端可识别的对象模型。服务器可以提供查看实时数据和历史数据的接口，并且由报警和事件组件来通知客户端重要的变量或事件变化。OPC UA可以被映射到一种通信协议上并且数据可以以不同的形式进行编码来达到传输便捷和高效的目的。</p><p>2.2 设计目标</p><pre><code>OPC UA提供了一个一致的、完整的地址空间和服务模型。这就允许一个单一的OPC UA服务器把数据，报警与事件和历史信息统一到它的地址空间里，并且可以用一套统一的服务为它们向外提供接口。这些服务也包括一个统一的安全模型。对于地址空间中要被访问的对象，OPC UA也允许服务器给客户端提供类型定义。这使得标准信息模型可以被用来描述地址空间的内容。OPC UA允许数据以不同的格式暴露出来，包括二进制结构和XML文档。数据格式可能被OPC或其他标准组织和厂商定义。通过地址空间，客户端能向服务器查询描述了数据格式的元数据。在许多情况下，没有数据格式编程知识的客户也能够在运行时刻决定数据格式并能恰当的使用数据。OPC UA扩充了对节点间关联的支持而不是把节点限制在单一的层面上。这样就使得，一个OPC UA服务器能从不同的层面提供数据，来满足客户端有选择性查看数据的要求。这种灵活性，不仅融合了对类型定义的支持，而且使得OPC UA适用于更宽泛的领域。所以，OPC UA不仅致力于现场遥测的服务层面，而且在上层管理功能上也提供了更好的互用性。OPC UA的目标是源源不断地提供已公布的数据。所有OPC服务器的一个主要特色就是发布数据和事件通知。OPC UA为客户端提供的机制可以使其快速检测到传输过程中的错误，并从中恢复过来，而不用等到底层协议所设定的超时时间结束。OPC UA目标也要支持更广泛的服务器，从底层的PLC到企业服务器。从容量，性能，执行平台和功能上区分这些服务器。因此，OPC UA定义了一系列功能，不同的服务器可能只实现所有功能中的某些功能。为了推动互操作性，OPC UA定义了标准子集，与协议相关，以保证不同服务器的一致性。客户随后可以得到一个服务器的协议，然后依靠协议来和服务器进行交互。规范的第七部分详细说明了协议。把OPC UA规范划分成不同的部分是为了把核心设计从底层的运算处理和网络传输分离出来。这使得OPC UA在不改变基础设计的情况下，被运用到未来技术上称为可能。映射和数据编码被定义在规范的第六部分。这里也定义了两种数据编码形式：1、可扩展标记语言/文本形式；2、UA 二进制形式。另外，这部分规范给出了两种传输协议：1、TCP（传输控制协议）；2、运用于HTTP（超文本传输协议）之上的网络服务简单对象访问协议。由于客户端和服务器支持多种传输形式和编码形式，这使得最终用户可以在实施阶段来确定性能和网络服务兼容性之间的平衡点，而不是由OPC厂商在生产定义阶段确定其平衡点。OPC UA的设计对于基于微软COM技术的OPC客户端和服务器来说，是可移植的。可移植性在设计OPC UA的时候已经给予了考虑，以至于由OPC COM服务器（数据访问，历史数据访问和事件报警）暴露出来的数据可以通过OPC UA进行映射和暴露出来。生产厂商既可以直接遵循OPC UA标准移植他们的产品，也可以对先前的产品进行外部封装来达到从OPC COM到OPC UA的过渡。先前每种OPC规范都是定义自己的地址空间和相应服务。OPC UA用一套服务把先前的各种模型统一到一个单一的地址空间里。</code></pre><p>2.3 统一的模型和服务<br>2.3.1 安全模型<br>2.3.1.1 概要</p><pre><code>OPC UA安全性主要考虑：客户端和服务器的合法性，用户的合法性，客户端和服务器之间通信的一致性和机密性，功能发布的真实性。OPC UA安全性不指定包含了多种必需安全机制的环境。安全模型规范是非常重要的，但是它可能在特定条件下由系统的设计者来制定，也可能由其他标准来指定。另外，OPC UA提供了一个安全模型，规范的第二部分给予了定义，安全方法可以针对给定设备进行选择和配置来满足其安全性需要。安全模型包括标准安全机制和参数。在某些情况下，用于交换安全参数的机制需要定义，但是运用这些参数的方法不用定义。框架也定义了所有UA服务器必须支持的最少安全功能子集，即使这个功能子集中的功能没有被用在所有设备中。规范的第七部分定义了安全性协议。</code></pre><p>2.3.1.2 建立会话</p><pre><code>应用程序级的安全性依靠一个安全的通信通道，这个通信通道在应用程序会话过程中始终有效，并且保证所有被交换信息的完整性。这也就意味着用户在应用程序会话建立时进行一次认证就可以了，不需要第二次认证。规范的第四部分和第六部分定义了建立安全通道和应用程序会话的机制。当一个会话建立时，客户端和服务器应用程序协商构造一个安全通信通道并且交换表明客户端和服务器身份的软件认证书还要交换各自所能提供功能的信息。OPC基金会发布的软件认证书显示了OPC UA中应用程序需要实现的基本要求，而且OPC UA认证标准贯彻到了每个协议中。规范的第七部分详细说明了每个协议和认证书的细节。由其他组织发行的认证也可能在会话建立期间进行交换。会话建立之后，服务器会对用户身份进行鉴别，随后批准用户对服务器中对象访问的请求。诸如访问控制列表这样的授权机制，OPC UA规范没有给予详细说明。这些机制与特定的应用程序或系统有关。</code></pre><p>2.3.1.3 审核</p><pre><code>在客户端和服务器审查日志可查的条件下，用户级安全性为安全审查记录提供支持。如果在服务器端检测到一个安全连接问题，与之关联的客户端将在其审查日志中添加相应条目。OPC UA也为服务器提供了产生审查事件通知的功能，审查事件通知可以向有能力处理和记录审查事件的客户端报告审查性的事件。OPC UA定义了标准审查参数，审查日志和审查事件通知都可以包含这些参数。规范的第五部分定义了这些参数的数据类型。并不是所有的服务器和客户端都提供所有的审查特性。规范第七部分的协议显示了所要支持的审查特性。</code></pre><p>2.3.1.4 传输安全性</p><pre><code>OPC UA安全性弥补了大部分网络服务可选平台上底层结构安全性的不足。传输级别上的安全性可以用来加密并标记消息。加密和标记技术防止了信息的泄露，保证了消息的完整性。用于在OPC UA应用程序之间传递消息的底层通信技术提供了加密功能。规范的第七部分定义了用于给定协议上的加密和标记方法。</code></pre><p>2.3.2 统一的地址空间模型</p><pre><code>OPC UA服务器为客户端提供的对象和相关信息都是与服务器的地址空间有关的。OPC UA地址空间是以一组用引用形式连接起来的节点来描绘它的内容的。OPC定义的属性描述了节点的原始特性。属性仅仅是一个服务器中拥有数值的元素。用来定义属性值的数据类型既可以是简单数据类型也可以是高级数据类型。依照地址空间中节点的用途和含义，把它们进行分类。节点类为OPC UA的地址空间定义了元数据。规范的第三部分定义了OPC UA节点类。节点基类定义了所有节点的公共属性。包括认证，分类和命名。每个节点类继承这些属性并可以另外定义自己的属性。为了提高客户端和服务器的互操作性，在对所有服务器进行最高级标准化的条件下，对OPC UA的地址空间进行分层组织。尽管地址空间中的节点经过分层后，是相对独立唯一的，但是节点之间可能存在引用关系。这就使得地址空间可以描绘出一个相关联的节点网络。规范的第三部分定义了地址空间模型。OPC UA服务器把地址空间以视点的形式划分成不同的子集，以此向客户端扩充自己的访问通道。3.3.3.3展示了地址空间视点的更多细节。</code></pre><p>2.3.3 统一的对象模型<br>    OPC UA对象模型提供了一套一致的、完整的节点类来描述地址空间中的对象。模型中根据对象包含的变量，事件，方法以及和其他对象的关系来描绘对象。规范的第三部分详细介绍了对象模型。</p><pre><code>OPC UA对象模型允许服务器为对象提供类型定义和对象组件。类型定义可以被继承，也可以标准化或是由系统指定。对象类型可以由OPC基金会，其他权威组织，生产商或最终用户来定义。统一对象模型允许把数据访问，事件报警，和历史数据访问功能集成到一个单一的OPC UA服务器中。例如，OPC UA服务器可以把一个温度传感器描述成一个对象，它由温度值，报警参数和相应的报警上下限组成。</code></pre><p>2.3.4 统一的服务<br>    OPC UA客户端和服务器之间的接口被定义成了一系列服务。这些服务又被组织划分成不同的组，每个组叫做服务子集。第四节对服务集进行了讨论，规范的第四部分详细说明了服务集。</p><pre><code>OPC UA服务向客户提供两种功能服务。首先，它们允许客户端向服务器发送请求并接受服务器的相应消息。而且，它们也允许客户端向服务器订阅通知。服务器用通知来发布某些事件的发生，如报警，数据值的改变，事件以及程序执行结果。为了提高传输性能，OPC UA消息可以被编码生XML文本格式或是二进制格式。它们可以使用多种传输协议进行传输，例如：TCP或是通过HTTP的网络服务。规范的第七部分介绍了不同的编码和传输机制。</code></pre><p>2.4 会话<br>    OPC UA需要一个状态模型。状态信息被保存在应用程序会话之中。例如，状态信息可能包括订阅信息，用户认证书和跨越多重请求操作的延长点信息。</p><pre><code>会话就是客户端和服务器之间的合法连接。服务器可以根据有效资源，许可限制或其他约束条件来限制并发的会话的数量。每个会话是不依赖底层通信协议的。通信协议的失败不会自动终止会话。会话的终止依靠客户端或服务器的指令，或客户端的失效。在会话建立时，要设定会话的间隔时间。</code></pre><p>2.5 冗余</p><pre><code>OPC UA的机制确保了开发商可以用同一种方式开发冗余客户端和服务器。冗余可用于提高系统的稳定性，容错性和负载平衡能力。规范的第四部分介绍了冗余的细节。规范的子协议中要求冗余支持，但是基本协议不需要冗余支持。</code></pre><p> 【3. OPC UA 系统概要】</p><p>3.1 总貌<br>    OPC UA系统结构以相互联系对象的方式模型化了OPC UA客户端和服务器。每个系统可能包含多个客户端和服务器。每个客户端可能同时与一个或多个服务器相连接，每个服务器也可能同时与一个或多个客户端相连接。一个应用程序可能同时包含了服务器和客户端的两部分组件，以此来达到与其他服务器和客户端的连接要求，3.3.6节描述了这种情况。</p><p>3.2 OPC UA客户端</p><pre><code>OPC UA客户端结构模型化了C/S结构中的客户端部分。客户端应用程序的代码实现了客户端的功能。客户端应用程序使用OPC UA客户端的API来向OPC UA服务器发送和接收相关服务的请求和响应。第四节介绍了OPC UA的服务，规范的第四部分详细说明了OPC UA的服务。注意到“OPC UA客户端API”是一个内部接口，它把客户端应用程序代码从OPC UA通信堆栈中分离出来了。OPC UA通信堆栈把OPC UA客户端的API调用转换成消息，并通过底层消息体发送给服务器，通知服务器客户端应用程序的请求。OPC UA通信堆栈也接受来自服务器的响应和通知消息，并通过OPC UA客户端API传递给客户端应用程序。</code></pre><p>3.3 OPC UA服务器</p><pre><code>OPC UA服务器结构模型化了C/S结构中的服务器部分。</code></pre><p>3.3.1 真实对象</p><pre><code>真实对象是可以由OPC UA服务器应用程序直接访问的物理设备或包含在其内部的软件程序。</code></pre><p>3.3.2 OPC UA服务器应用程序</p><pre><code>OPC UA服务器应用程序的代码实现了服务器的功能。服务器应用程序使用OPC UA服务器的API来向OPC UA客户端发送和接收消息。注意到“OPC UA服务器API”是一个内部接口，它把服务器应用程序代码从OPC UA通信堆栈中分离出来了。这可能是OPC基金会提供的一个标准应用或是由生产商制定的应用。</code></pre><p>3.3.3 OPC UA地址空间<br>3.3.3.1 地址空间节点<br>    地址空间由一系列节点组成，客户端可以通过使用OPC UA服务（接口和方法）来访问节点。地址空间中的节点用来代表真实对象，以及它们的定义和相互之间的引用。</p><p>3.3.3.2 地址空间组织</p><pre><code>规范的第三部分讲述了用“积木”模型以一种标准的一致的方式构造空节点地址空间的细节。服务器可以在它们的地址空间中自由的组织它们选择的节点。节点间引用的使用，允许服务器可以把地址空间组织成分层结构，网状节点结构，或任何可能的结构混合。</code></pre><p>规范的第五部分定义了OPC UA节点，引用以及它们在地址空间中组织结构的标准。</p><p>3.3.3.3 地址空间概要<br>    视点是地址空间的子集。视点限制了服务器向客户端暴露的节点数量，也就限制了客户端所能请求到的地址空间尺寸。视点的默认设置是整个地址空间。服务器可以有选择的定义其他视点。视点也就隐藏地址空间中的某些节点和引用。通过地址空间视点是可见的，客户端可以通过浏览视点从而确定它们的结构。视点通常是分层结构的，这样利于客户用树形结构来理解和表示它。</p><p>3.3.3.4 对信息模型的支持<br>    OPC UA地址空间支持信息模型。支持如下：a)节点引用允许地址空间中的对象相互关联；b)对象类型节点为真实对象提供语义信息（类型定义）；c)对象类型节点支持类型定义子集；d)地址空间中暴露的数据类型定义允许使用工业上特定的数据类型；e)OPC UA的联合标准允许工业团体在OPC UA服务器的地址空间中制定它们特定信息模型的表示方法。</p><p>3.3.4.1 监控项<br>    监控项是由客户端在服务器中创建的实体，它用来监控地址空间中的节点和它们现实世界中所对应的实体。当监控项检测到数据变化或有事件或报警发生时，它们就产生通知，由订阅传送给客户端。</p><p>3.3.4.2 订阅<br>    订阅是服务器中的一个终端，它用来向客户端发布通知。它是客户端控制发布的条件。</p><p>3.3.5 OPC UA服务接口<br>3.3.5.1 概要<br>    第四节对OPC UA定义的服务进行了介绍，规范的第四部分对它们进行了详细说明。<br>3.3.5.2 请求/响应服务<br>    请求或响应服务是由客户端通过OPC UA服务接口调用的服务，它们对地址空间中的节点进行特定的操作并返回操作结果。<br>3.3.5.3 发布服务<br>    发布服务是由客户端通过OPC UA服务接口调用的服务，它的作用是周期性地向客户端发送通知。通知都包括事件，报警，数据变化以及程序输出结果。<br>3.3.6 服务器之间的关联<br>    服务器之间的关联就是一个服务器作为另一个服务器的客户端。服务器之间的关联考虑到了服务器的以下拓展能力：a)相互间以点对点的形式交换信息，这使得一个服务器可以连接一个冗余服务器或是一个远程服务器，用它们来保存系统额外的类型定义；b)以分层结构链接起来的服务器可以提供如下功能：1)集合底层服务器的数据；2)上层数据发往客户端；3)客户端的接口层为每个底层服务器提供单一访问结点。</p><p>【4. OPC UA 服务设置】</p><p>4.1 概要</p><pre><code>OPC UA服务被划分成不同的服务子集，每个子集定义了一组逻辑上相关的服务，用于显示服务器一个特定的方面。以下介绍了服务子集。规范的第四部分详细说明了服务子集和它们所包含的服务。无论一个服务器是否支持一个服务子集，服务子集中的特定服务都被服务器的协议所定义。规范的第七部分介绍了协议。</code></pre><p>4.2 安全通道服务集</p><pre><code>这个服务子集定义的服务用作去查询一个服务器的安全配置并且构造一个通信通道，这个通道可以确保与服务器交换的所有消息是保密的，完整的。规范的第二部分定义了UA安全性的基本概念。安全通道服务与其他服务不同，因为安全通道服务不被UA应用程序直接执行。它们是由UA应用程序所依靠的通信堆栈来提供的。例如，一个UA服务器可能被建立在一个简单对象访问协议堆栈上，这个协议堆栈允许应用程序使用网络服务安全会话规范建立安全通道。在这些情况下，当UA应用程序接收到消息时，它仅需要校验网络服务安全会话是可用的。规范的第六部分描述了安全通道服务如何被使用。安全通道是单一客户端和单一服务器之间一个长期运行的合法连接。通道内保存了许多只有客户端和服务器知道的密钥，这些密钥用于认证和编码在网络间传输的消息。安全通道服务允许客户端和服务器安全协商密钥的使用方法。服务器的安全策略描述了鉴定和加密消息的确切算法。一个客户端在构造一个安全通道时，必须选择一种服务器所支持的安全策略。当一个客户端和服务器通过安全通道进行通信时，它们必须核实所有正在传入的消息已经依照某种安全策略进行了标识和加密。一个UA应用程序不能处理通道内不符合安全策略的消息。安全通道与UA应用程序会话是相分离的，然而，一个UA应用程序会话只能通过唯一的安全通道进行访问。这说明了UA应用程序必须能够决定每条消息所联系的安全通道。通信堆栈提供了安全通道机制，但它不允许应用程序知道用于给定消息的安全通道，是不能用于完成安全通道服务的。UA应用程序用通信堆栈去交换消息。首先，用安全通道服务在通信堆栈间构造一个安全通道，使得通信堆栈之间可以安全交换消息。然后，UA应用程序使用会话服务子集构造一个UA应用程序会话。当一个客户端构造一个安全通道时，它可能提供一个用户标识。这个标识可能与客户端初始化UA应用程序会话时所提供的用户标识不一样。</code></pre><p>4.3 会话服务集<br>    这个服务集定义的服务用作去构造一个应用层的连接，这个连接就是为了一个特定用户而建立的会话。</p><p>4.4 节点管理服务集</p><pre><code>节点管理服务集允许客户去添加，修改以及删除地址空间里的节点。这些服务为服务器的构造提供了一个标准接口。</code></pre><p>4.5 视点服务集</p><pre><code>视点是由服务器创造的地址空间子集。视点的默认值是全部地址空间。因此，视点服务可以操作整个地址空间。规范的未来版本可能会制定相应服务来构造客户端定义的视点。视点服务允许客户端通过浏览视点查找节点。客户端在视点中进行分层查找，或通过节点间的引用进行查找。在这种方式下，也允许客户端查看视点的结构。</code></pre><p>4.6 属性服务集</p><pre><code>属性服务集用作去读写属性值。属性是由OPC UA定义的节点原始特性。它们可能不是由客户端和服务器来定义的。属性是地址空间中允许存放数据值的唯一元素。一个特定的属性，属性值用来定义变量的值。</code></pre><p>4.7 方法服务集</p><pre><code>方法代表了对象的函数调用。规范的第三部分定义了方法服务。方法被调用，无论成功与否，都在方法执行完毕后返回。不同方法的运行时间可能不同，这主要取决于它们运行的函数。方法服务集定义了调用方法的手段。一个方法必须是一个对象的组件。方法的暴露由浏览和查询服务来提供。客户端查询一个服务器所支持的方法是通过浏览特有的对象来完成的，这些对象标识了自己所支持的方法。因为方法可以控制设备操作的某些环节，所以方法调用可能依靠环境条件或其他条件。这使得反复调用同一种方法成为可能。需要调用方法的条件可能先前并没有返回一个允许该方法重新启动的状态。另外，有些方法可能支持并发调用，而有些方法只能单独调用。</code></pre><p>4.8 监视项服务集</p><pre><code>监视项服务集被客户端用来去构造和保存监视项。监视项用来监视变量，属性和事件通知器。当它们检测到特定条件发生时，它们会产生相应通知。监视项监视变量数值，状态或时间戳的变化；属性值的变化；以及事件通知器对新产生的报警和事件的报告。每个监视项都标识了要监视的项目和用于向客户端周期性发布通知的订阅（参阅4.9节）。每个监视项也指定了被监视项目的采集频率，对于变量和事件通知器，用过滤标准来决定什么时候来产生通知。属性的过滤标准由规范第四部分的属性定义来加以说明。监视项的采样速度可能比订阅的发布速度更快。所以，监视项可能由一个包含所有通知的队列组成，或是由一个仅含有最近通知的队列组成。第二种情况，队列里只含有一个通知。监视项服务也定义了一个监视模式。这个模式可以配置成三种模式：不采集不报告模式，仅采集模式，或是既采集也报告模式。当设置了采集模式时，服务器采集被监视项的值（或状态）。另外，通过对采集结果的判断来决定是否产生一个通知。如果需要产生通知，则构建一个通知队列。如果允许报告，则通知队列可以由订阅来向外发送。最后，一个监视项的报告选项能够由其他监视项来设置。在这种情况下，需要报告的监视项的监视模式仅需要再设置采集选项就可以了，当被触发的监视项产生一个通知时，需要报告的监视项通知队列由订阅来向外发送。</code></pre><p>4.9 订阅服务集</p><pre><code>订阅服务集由客户端构造并保持和使用。订阅周期性的发布来自它们相关监视项的通知消息（参阅4.7节）。所有通知都应包含一个公共消息头。通知的格式与被监视项目的类型有关。（例如：变量，属性，和事件通知器）。已构造出的存在的订阅并不依靠客户端与服务器的会话。这就允许由一个客户端来构造订阅，另一个客户端，可能是冗余客户端，从订阅上来接受通知消息。有些客户端并不需要订阅，所以订阅设置了一个由客户端周期性更新的生命周期属性。如果客户端没有成功更新订阅的生命周期，则订阅终止，服务器关闭订阅。当一个订阅被关闭后，所有与它关联的监视项都被删除。订阅也包括支持检测和恢复丢失消息的特性。每个通知消息都包含一个允许客户端检测丢失消息的序号。当没有通知在有效时间间隔内需要发送时，服务器发送一个保持消息，它含有最后一次被传送消息的序号。如果客户端在通信时间间隔终止之后还没有收到消息，它可以要求服务器重发先前消息。</code></pre><p>4.10 查询服务集</p><pre><code>查询服务集允许客户端选择地址空间中的一个节点子集或是一个视点中的节点子集，视点建立在客户端提供的过滤标准的基础上。被查询服务选择的节点和属性叫做一个结果集。结果集可能是节点的简单组合，其中也可能包含了节点间引用的结构。服务器可能发现有些查询不好处理，如查询诸如设备数据一样的实时数据，或是查询操作需要消耗大量资源或存在较长延时。这些情况下，服务器可以拒绝查询。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OPC是一个工业标准，属于&lt;a href=&quot;https://opcfoundation.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OPC基金会&lt;/a&gt;，现有会员已超过220家，包括世界上所有主要的自动化控制系统、仪器仪表及过程控制系统的公司。
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="OPC" scheme="http://yoursite.com/tags/OPC/"/>
    
  </entry>
  
  <entry>
    <title>CC-Link通信协议</title>
    <link href="http://yoursite.com/2018/05/16/knowledge/know-ccl/"/>
    <id>http://yoursite.com/2018/05/16/knowledge/know-ccl/</id>
    <published>2018-05-16T06:51:47.000Z</published>
    <updated>2018-05-16T06:52:26.197Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="industrial network - field bus - protocol" scheme="http://yoursite.com/tags/industrial-network-field-bus-protocol/"/>
    
  </entry>
  
  <entry>
    <title>CIP通信协议及其衍生</title>
    <link href="http://yoursite.com/2018/05/16/knowledge/know-cip/"/>
    <id>http://yoursite.com/2018/05/16/knowledge/know-cip/</id>
    <published>2018-05-16T06:38:11.000Z</published>
    <updated>2018-05-16T06:41:01.474Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="protocol" scheme="http://yoursite.com/tags/protocol/"/>
    
      <category term="industrial network" scheme="http://yoursite.com/tags/industrial-network/"/>
    
      <category term="field bus" scheme="http://yoursite.com/tags/field-bus/"/>
    
  </entry>
  
  <entry>
    <title>USS通用串行接口协议</title>
    <link href="http://yoursite.com/2018/05/14/knowledge/know-uss/"/>
    <id>http://yoursite.com/2018/05/14/knowledge/know-uss/</id>
    <published>2018-05-14T08:37:37.000Z</published>
    <updated>2018-05-15T01:15:49.937Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="protocol" scheme="http://yoursite.com/tags/protocol/"/>
    
      <category term="USS" scheme="http://yoursite.com/tags/USS/"/>
    
      <category term="serial communication" scheme="http://yoursite.com/tags/serial-communication/"/>
    
  </entry>
  
  <entry>
    <title>CRC循环冗余校验码</title>
    <link href="http://yoursite.com/2018/05/14/knowledge/know-crc/"/>
    <id>http://yoursite.com/2018/05/14/knowledge/know-crc/</id>
    <published>2018-05-14T01:30:53.000Z</published>
    <updated>2018-05-15T01:15:02.561Z</updated>
    
    <content type="html"><![CDATA[<p><strong>循环码</strong>(Cyclic Redundancy Check, CRC)是一种检错率高、编码效率高的检错码，通过除法运算来建立有效信息位和校验位之间的约定关系。<br><a id="more"></a><br>CRC码由两部分组成，前部分是<strong>信息码</strong>，后部分是<strong>校验码</strong>，若CRC码总共长$n$位，信息码长$k$位，则称为<strong>$(n,k)$码</strong>，$r=n-k$即冗余位长度，也就是校验码长度。</p><p>基本概念：</p><ul><li>$n$位二进制码可以表示最高次幂为$n-1$的多项式。</li><li><strong>按位除</strong>（模2除）运算实际上就是在除的过程中做异或运算，同时不考虑进位，直到余数的位数小于除数时得到最终余数。在异或运算中模2减与模2加真值表完全相同。</li></ul><p>对于一个给定的$(n,k)$码，可以证明存在最高次幂为$r$的<strong>生成多项式</strong>$G(x)$，满足</p><ol><li>最高位和最低位为1</li><li>当被传送信息任何一位发生错误时，被生成多项式做模2除后使余数不为0</li><li>不同位发生错误时使余数不同</li><li>对余数继续做模2除应使余数循环</li></ol><p>将这些条件反映为数学关系是复杂的，常用的对应不同码制的生成多项式$G(x)$详见<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener">Wikipedia</a>：</p><ul><li>CRC1:  $x^1+x^0$</li><li>CRC4:  $x^4+x^1+x^0$</li><li>CRC8:  $x^8+x^5+x^4+x^0$</li><li>CRC12: $x^{12}+x^{11}+x^3+x^2+x^0$</li><li>CRC16: $x^{16}+x^{15}+x^2+x^0$</li></ul><p>具体<strong>编码规则</strong>如下。</p><ol><li>接收方和发送方约定发送组的信息位k和冗余位r个数，选定生成多项式$G(x)$满足上述条件</li><li>发送方将原始数据左移$r$位得到$M(x)$，随后按位除生成多项式$G(x)$，得到余数$R(x)$，有$\frac{M(x)}{G(x)}=Q(x)…R(x)$</li><li>发送方将$M(x)$与$R(x)$连接（等同于模2加或模2减）后一起发送</li><li>接收方将收到的数据按位除生成多项式$G(x)$，若余数为$0$则传输正确，若余数不为$0$则传输错误，即$\frac{M(x)+R(x)}{G(x)}=\frac{M(x)-R(x)}{G(x)}=Q(x)…0$</li></ol><p>CRC校验码可以检查出全部单个错、全部离散二位错、全部奇数个数、全部长度小等于$k$位的突发错，并以$1-(1/2)^{k-1}$概率检查出长度位$k+1$位的突发错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;循环码&lt;/strong&gt;(Cyclic Redundancy Check, CRC)是一种检错率高、编码效率高的检错码，通过除法运算来建立有效信息位和校验位之间的约定关系。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="communication basis" scheme="http://yoursite.com/tags/communication-basis/"/>
    
      <category term="error-detecting code" scheme="http://yoursite.com/tags/error-detecting-code/"/>
    
  </entry>
  
  <entry>
    <title>网络传输电气知识</title>
    <link href="http://yoursite.com/2018/05/14/knowledge/know-networkelectric/"/>
    <id>http://yoursite.com/2018/05/14/knowledge/know-networkelectric/</id>
    <published>2018-05-14T01:07:37.000Z</published>
    <updated>2018-05-15T01:17:51.639Z</updated>
    
    <content type="html"><![CDATA[<p>数字表示网络数据传输速率，单位为Mbps；Base表示基带传输，即未经过调制、不能复用的传输，Broad表示宽带传输；-后面的字母或数字指传输介质。<br><a id="more"></a><br>IEEE标准共有以下几种：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">传输介质</th><th style="text-align:center">传输距离</th><th style="text-align:center">连接器</th></tr></thead><tbody><tr><td style="text-align:center">10Base-5</td><td style="text-align:center">RG-8/RG-11同轴电缆（粗缆）</td><td style="text-align:center">500米</td><td style="text-align:center">AUI或MAU连接器</td></tr><tr><td style="text-align:center">10Base-2</td><td style="text-align:center">RG-58同轴电缆（细缆）</td><td style="text-align:center">185米</td><td style="text-align:center">BNC连接器</td></tr><tr><td style="text-align:center"><strong>10Base-T</strong></td><td style="text-align:center">CAT3非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">10Base-F</td><td style="text-align:center">光纤</td><td style="text-align:center">500米以上</td><td style="text-align:center">FP/FL/FB连接器</td></tr><tr><td style="text-align:center"><strong>100Base-TX</strong></td><td style="text-align:center">CAT5非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">100Base-T4</td><td style="text-align:center">CAT3非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">100Base-F</td><td style="text-align:center">光纤</td><td style="text-align:center">2000米</td><td style="text-align:center">SC</td></tr><tr><td style="text-align:center"><strong>1000Base-T</strong></td><td style="text-align:center">CAT5e非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center"><strong>1000Base-TX</strong></td><td style="text-align:center">CAT6非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">1000Base-CX</td><td style="text-align:center">屏蔽双绞线</td><td style="text-align:center">25米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">1000Base-LX</td><td style="text-align:center">单模光纤</td><td style="text-align:center">3000米</td><td style="text-align:center">SFP</td></tr><tr><td style="text-align:center">1000Base-SX</td><td style="text-align:center">多模光纤</td><td style="text-align:center">300-550米</td></tr></tbody></table><p><strong>双绞线</strong>把两根22-26号绝缘铜导线按一定密度互相绞在一起，每一根导线在传输中辐射出来的电波会被另一根线上发出的电波抵消，有效降低信号干扰的程度。与其他传输介质相比，双绞线在传输距离，信道宽度和数据传输速度等方面均受到一定限制，但价格较为低廉，应用非常广泛。<br><strong>屏蔽双绞线</strong>在双绞线与外层绝缘封套之间有一个金属屏蔽层。<strong>STP</strong>(Shielded Twisted Pair)指每条线都有各自的屏蔽层，而<strong>FTP</strong>(Foil Twisted Pair)只在整个电缆有屏蔽装置，并且两端都正确接地时才起作用。屏蔽层可减少辐射，防止信息被窃听，也可阻止外部电磁干扰，屏蔽双绞线比同类的非屏蔽双绞线具有更高的传输速率。<br><strong>非屏蔽双绞线UTP</strong>(Unshielded Twisted Pair)直径小、成本低、易弯曲、易安装，广泛用于以太网和电话线中。常见的非屏蔽双绞线由4对8根不同颜色的传输线组成。<br><img src="/2018/05/14/knowledge/know-networkelectric/twisted_pair.jpg" alt="twisted pair"><br>按照频率带宽和信噪比双绞线可以分为：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">最高频率带宽</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:center">CAT1</td><td style="text-align:center">750kHz</td><td style="text-align:left">用于报警系统，不用于数据传输</td></tr><tr><td style="text-align:center">CAT2</td><td style="text-align:center">1MHz</td><td style="text-align:left">用于语音传输和最高4Mbps的数据传输</td></tr><tr><td style="text-align:center">CAT3</td><td style="text-align:center">16MHz</td><td style="text-align:left">用于10Base-T以太网和4Mbps令牌环</td></tr><tr><td style="text-align:center">CAT4</td><td style="text-align:center">20MHz</td><td style="text-align:left">用于局域10Base-T/100Base-T以太网和16Mbps令牌环</td></tr><tr><td style="text-align:center"><strong>CAT5</strong></td><td style="text-align:center">100MHz</td><td style="text-align:left">用于10Base-T/100Base-T网络</td></tr><tr><td style="text-align:center">CAT5e</td><td style="text-align:center">100MHz</td><td style="text-align:left">用于1000Base-T网络</td></tr><tr><td style="text-align:center">CAT6</td><td style="text-align:center">250MHz</td><td style="text-align:left">用于最高1Gbps的数据传输</td></tr><tr><td style="text-align:center">CAT6A</td><td style="text-align:center">500MHz</td><td style="text-align:left">用于最高10Gbps的数据传输</td></tr><tr><td style="text-align:center">CAT7</td><td style="text-align:center">600MHz</td><td style="text-align:left">用于最高10Gbps的数据传输</td></tr></tbody></table><p>目前最常用的为CAT5和CAT6，CAT6以上的产品国家未出台正式检测标准。电话线接口常用RJ11连接器，网线接口常用RJ45连接器，都称为水晶头。</p><p>EIA/TIA标准规定了两种双绞线线序T568A和T568B，常用网线分为<strong>直连互联</strong>和<strong>交叉互联</strong>两种接法。<br>可以看作<strong>数据终端设备</strong>(Data Terminal Equipment, DTE)的有电脑、路由器、交换机uplink口、HUB级联口等，可以看<strong>数据电路终接设备</strong>(Data Circuit-terminating Equipment, DCE)的有交换机普通口、HUB普通口等。同类设备间相连使用交叉线方式，异类设备间相连使用直通线方式。现在的交换机通常具有端口自动翻转功能，因此对直通线和交叉线不加以区分。<br><img src="/2018/05/14/knowledge/know-networkelectric/utp&amp;stp.jpg" alt="twisted pair"></p><p><strong>单模光纤</strong>中心的玻璃芯很细，只能传播一种模式的光信号，在单模光纤中光沿直线传播，无反射，传播距离非常远，一般为黄色。<strong>多模光纤</strong>芯径较大，可以传输多种模式的光信号，一般为橘红色或灰色，不同模光进入光纤的角度不同，它们到达另一端的时间也不同，称为<strong>模分散</strong>，模分散技术限制了多模光纤的带宽和距离。<br><img src="/2018/05/14/knowledge/know-networkelectric/optical_fiber.JPG" alt="twisted pair"></p><p>常见的光纤接口包括SC（方形卡接式）、LC（圆形小）、DLC（圆形小双头）、FC（圆形带螺纹）、ST（圆形卡接式）和MTRJ（方形双头）等，插芯研磨平面又可以分为PC、UPC、APC等。<br><strong>光电转换器</strong>又称光纤收发器，是一种将短距离电信号和长距离光信号进行互换的设备，目前最常用的光电转换器为热插拔小封装模块(Small Form-factor Pluggables, SFP)，具有体积小、端口多等优点，多采用LC接口。<strong>光纤耦合器</strong>又称分歧器，将光信号从一条光纤中分至多条光纤中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数字表示网络数据传输速率，单位为Mbps；Base表示基带传输，即未经过调制、不能复用的传输，Broad表示宽带传输；-后面的字母或数字指传输介质。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="network basis" scheme="http://yoursite.com/tags/network-basis/"/>
    
      <category term="electric" scheme="http://yoursite.com/tags/electric/"/>
    
  </entry>
  
  <entry>
    <title>工业控制设备通信概览</title>
    <link href="http://yoursite.com/2018/05/10/review/rev-industrialcomm/"/>
    <id>http://yoursite.com/2018/05/10/review/rev-industrialcomm/</id>
    <published>2018-05-10T03:38:56.000Z</published>
    <updated>2018-05-16T06:54:17.229Z</updated>
    
    <content type="html"><![CDATA[<p>工业以太网、现场总线、工业无线是目前工业通信领域的三大主流技术。</p><a id="more"></a><p>IEC 61158于2007年第四版标准规定了20种类型的通信协议：<br><img src="/2018/05/10/review/rev-industrialcomm/IEC.JPG" alt="IEC">其中Type1可以理解为FF现场总线，Type2包括DeviceNet、ControlNet和EtherNet/IP，Type6由于应用不理想被撤销。</p><p>常见工业现场总线一览：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">推出时间</th><th style="text-align:center">主推公司</th><th>特点</th><th>链接</th></tr></thead><tbody><tr><td style="text-align:center">ASi (AS-Interface)</td><td style="text-align:center"></td><td style="text-align:center"></td><td>$1</td><td></td></tr><tr><td style="text-align:center">CAN</td><td style="text-align:center">1986</td><td style="text-align:center">博世</td><td></td><td></td></tr><tr><td style="text-align:center">CC-Link</td><td style="text-align:center">1996</td><td style="text-align:center">三菱</td><td></td><td><a href="/2018/05/16/knowledge/know-ccl/" title="CC-Link通信协议">CC-Link通信协议</a></td></tr><tr><td style="text-align:center">CompoNet</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">ControlNet</td><td style="text-align:center">1997</td><td style="text-align:center">罗克韦尔</td><td></td><td><a href="/2018/05/16/knowledge/know-cip/" title="CIP通信协议及其衍生">CIP通信协议及其衍生</a></td></tr><tr><td style="text-align:center">DeviceNet</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td><a href="/2018/05/16/knowledge/know-cip/" title="CIP通信协议及其衍生">CIP通信协议及其衍生</a></td></tr><tr><td style="text-align:center">Fipio</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">InterBus</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">LonWorks</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center"><strong>Modbus</strong></td><td style="text-align:center">1979</td><td style="text-align:center">施耐德</td><td></td><td><a href="/2018/05/03/knowledge/know-modbus/" title="Modbus通信协议">Modbus通信协议</a></td></tr><tr><td style="text-align:center"><strong>Profibus</strong></td><td style="text-align:center">1986</td><td style="text-align:center">西门子</td><td></td><td><a href="/2018/05/04/knowledge/know-profi/" title="Profibus和Profinet通信协议">Profibus和Profinet通信协议</a></td></tr></tbody></table><p>常见工业网络协议一览：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">推出时间</th><th style="text-align:center">主推公司</th><th>特点</th><th>链接</th></tr></thead><tbody><tr><td style="text-align:center">CC-Link IE</td><td style="text-align:center">xxxx</td><td style="text-align:center">三菱</td><td></td><td><a href="/2018/05/16/knowledge/know-ccl/" title="CC-Link通信协议">CC-Link通信协议</a></td></tr><tr><td style="text-align:center">EtherCAT</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">EtherNet/IP</td><td style="text-align:center">2000</td><td style="text-align:center"></td><td></td><td><a href="/2018/05/16/knowledge/know-cip/" title="CIP通信协议及其衍生">CIP通信协议及其衍生</a></td></tr><tr><td style="text-align:center"><strong>Modbus-TCP</strong></td><td style="text-align:center">1998</td><td style="text-align:center">施耐德</td><td></td><td><a href="/2018/05/03/knowledge/know-modbus/" title="Modbus通信协议">Modbus通信协议</a></td></tr><tr><td style="text-align:center"><strong>Profinet</strong></td><td style="text-align:center">2001</td><td style="text-align:center">西门子</td><td></td><td><a href="/2018/05/04/knowledge/know-profi/" title="Profibus和Profinet通信协议">Profibus和Profinet通信协议</a></td></tr><tr><td style="text-align:center">SERCOS Ⅲ</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><p>其他通信协议：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">推出时间</th><th style="text-align:center">主推公司</th><th>特点</th><th>链接</th></tr></thead><tbody><tr><td style="text-align:center">BACnet</td><td style="text-align:center">wangluo</td><td style="text-align:center"></td><td></td><td>$1</td></tr><tr><td style="text-align:center">GD (Global Data)</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">Ethernet TCP/IP</td><td style="text-align:center">以太网</td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">IO-Link</td><td style="text-align:center">点对点</td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">USS</td><td style="text-align:center"></td><td style="text-align:center">西门子</td><td></td><td><a href="/2018/05/14/knowledge/know-uss/" title="USS通用串行接口协议">USS通用串行接口协议</a></td></tr><tr><td style="text-align:center">USB</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工业以太网、现场总线、工业无线是目前工业通信领域的三大主流技术。&lt;/p&gt;
    
    </summary>
    
      <category term="review" scheme="http://yoursite.com/categories/review/"/>
    
    
      <category term="protocol" scheme="http://yoursite.com/tags/protocol/"/>
    
      <category term="industrial network" scheme="http://yoursite.com/tags/industrial-network/"/>
    
      <category term="field bus" scheme="http://yoursite.com/tags/field-bus/"/>
    
  </entry>
  
  <entry>
    <title>《数据库原理与应用》笔记</title>
    <link href="http://yoursite.com/2018/05/10/note/note-database/"/>
    <id>http://yoursite.com/2018/05/10/note/note-database/</id>
    <published>2018-05-10T03:31:31.000Z</published>
    <updated>2018-05-29T08:34:48.706Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《数据库原理与应用——SQL Server 2016版本》 主编：邓立国 佟强 清华大学出版社 2017年9月第1版 TP311.138 ISBN: 978-7-302-48305-2 </strong><br>本书系统地讲述数据库原理与SQL Server 2016的功能、应用及实践知识，包括关系数据库知识、数据库创建与维护、数据库表的操作管理及维护、完整性控制、查询与管理表数据、Transaction-SQL编程、存储过程和触发器、数据库安全管理、数据库系统开发配置连接等知识。<br><a id="more"></a></p><!-- toc --><ul><li><a href="#第一章-数据库基础知识">第一章 数据库基础知识</a></li><li><a href="#第四章-数据库设计与编程">第四章 数据库设计与编程</a></li><li><a href="#第六章-数据库操作">第六章 数据库操作</a></li><li><a href="#第七章-数据表操作">第七章 数据表操作</a><ul><li><a href="#71-数据类型">7.1 数据类型</a></li><li><a href="#72-操作表">7.2 操作表</a></li><li><a href="#74-表约束">7.4 表约束</a></li></ul></li><li><a href="#第八章-数据操作">第八章 数据操作</a></li><li><a href="#第十章-存储过程与触发器">第十章 存储过程与触发器</a></li><li><a href="#第十一章-数据库安全">第十一章 数据库安全</a></li></ul><!-- tocstop --><h2><span id="第一章-数据库基础知识">第一章 数据库基础知识</span></h2><!-- ## 第三章 关系数据库标准语言SQL --><!-- **结构化查询语言（Structured Query Language, SQL）**是关系数据库的标准语言，具有集数据查询、数据操作、数据定义和数据控制于一体的强大功能。| SQL功能 | 动词 || :-----: | :--- || 数据查询 | SELECT || 数据定义 | CREATE、DROP、ALTER || 数据操纵 | INSERT、UPDATE、DELETE || 数据控制 | GRANT、REVOKE |支持SQL的RDBMS同样支持关系数据库二级模式结构，外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件的逻辑结构，其物理结构是任意的，对用户是透明的。各个RDBMS产品在实现标准SQL时有所差别。 --><!-- ## 3.1 数据定义只有拥有DBA权限的用户才能调用创建模式的命令。创建和删除模式的语句：    CREATE SCHEMA [模式名] AUTHORIZATION 用户名 [SQL语句]    DROP SCHEMA 模式名 [{RESTRICT|CASCADE}]基本表的定义和删除 --><h2><span id="第四章-数据库设计与编程">第四章 数据库设计与编程</span></h2><h2><span id="第六章-数据库操作">第六章 数据库操作</span></h2><h2><span id="第七章-数据表操作">第七章 数据表操作</span></h2><p><strong>表</strong>是关系模型中表示实体的方式，是数据库存储数据的主要对象，同一数据库不能有相同表名。SQL Server中表由行和列组成，行称为<strong>记录</strong>，列称为<strong>字段</strong>，行和列的顺序都是任意的，一个表最多可以定义1024列且列名唯一。</p><h3><span id="71-数据类型">7.1 数据类型</span></h3><p><img src="/2018/05/10/note/note-database/data_type.JPG" alt="data_type"></p><h3><span id="72-操作表">7.2 操作表</span></h3><p><strong>创建表</strong>一般要经过定义表结构、设置约束和添加数据三个步骤。设计表结构时需要确定表的名称、表包含的各个列名、数据类型和长度、能否为空值等。</p><p>数据表可以通过图形界面创建，也可以通过SQL语句：</p><pre><code>CREATE TABLE [数据库名][所有者]表名(列名 数据类型 [{NULL|NOT NULL}] [,... n])[ON {文件组|&quot;default&quot;}]</code></pre><p><strong>删除表</strong>可以通过SQL语句：</p><pre><code>DROP TABLE 表名 [{RESTRICT|CASCADE}]</code></pre><p>使用SQL语句<strong>对表进行操作</strong>，增加、删除列和修改列属性的语句：</p><pre><code>ALTER TABLE 表名ADD 列名 数据类型 [{NULL|NOT NULL}] [,... n]DROP COLUMN 列名 [,... n]ALTER COLUMN 列名 数据类型 [{NULL|NOT NULL}] [,... n]</code></pre><p>此外，查看表的属性、重命名表、重命名列可以通过调用存储过程实现：</p><pre><code>EXEC sp_helpEXEC sp_rename &apos;旧名&apos;, &apos;新名&apos;, {&apos;TABLE&apos;|&apos;COLUMN&apos;}</code></pre><!-- ### 7.3 操作数据操作表数据同样可以通过图形界面或SQL语句实现。 --><h3><span id="74-表约束">7.4 表约束</span></h3><h2><span id="第八章-数据操作">第八章 数据操作</span></h2><h2><span id="第十章-存储过程与触发器">第十章 存储过程与触发器</span></h2><p><strong>存储过程</strong>是由一系列Transact-SQL语句构成的程序，经编译后存储在数据库中，可以通过名称直接调用。存储过程还可以接受参数，提高存储过程的灵活性。在SQL Server中，存储过程的类型主要有：用户存储过程、扩展存储过程和系统存储过程。<strong>用户存储过程</strong>包括Transact-SQL存储过程和CLR存储过程；<strong>扩展存储过程</strong>可以加载外部DLL；<strong>系统存储过程</strong>用来实现数据库的管理活动，存放在master中，但其他数据库也可以调用。常用系统存储过程和分类见书P301。</p><p>创建和修改存储过程的语法：</p><pre><code>{CREATE|ALTER} PROC[EDURE] 存储过程(组)名[;序号][{@参数名 数据类型} [=默认值] [OUTPUT]] [,... n][WITH {RECOMPILE|ENCRYPTION|RECOMPILE,ENCRYPTION}][FOR REPLICATION]AS {SQL语句 [,... n]} </code></pre><p>删除存储过程的语法：</p><pre><code>DROP PROC[EDURE] 存储过程(组)名</code></pre><p>执行存储过程的语法：</p><pre><code>EXEC[UTE] 存储过程(组)名[;序号][[@参数名=]参数值|@参数名 [OUTPUT]|[DEFAULT]] [,... n][WITH RECOMPILE]</code></pre><p><strong>触发器</strong>是一种特殊的存储过程，可以看作是表定义的一部分，用于对表进行完整性约束。在SQL Server中，触发器的类型主要有：DML触发器、DDL触发器和登录触发器。</p><p>当数据库中发生数据操纵语言(DML)事件时将调用<strong>DML触发器</strong>。按照触发操作的不同可以分为INSERT触发器、UPDATE触发器和DELETE触发器，SQL Server为每个语句创建deleted表或（和）inserted表，表结构与定义触发器的表结构相同，触发器执行完成后自动删除。按照触发时间的不同可以分为AFTER(FOR)触发器和INSTEAD OF触发器。<br>当数据库中发生数据定义语言(DLL)事件时将调用<strong>DLL触发器</strong>，主要用于任务管理。DLL事件主要包括CREATE/ALTER/DROP/GRANT/DENY/REVOKE等语句操作。<br>LOGON事件激发<strong>登录触发器</strong>，将在登录身份验证阶段完成之后用户会话建立之前触发。</p><p>创建和修改DML触发器的语法：</p><pre><code>{CREATE|ALTER} TRIGGER [模式名.]触发器名ON {表名|视图名}[WITH DML触发器选项 [,... n]]{FOR|AFTER|INSTEAD OF}{[INSERT][,][UPDATE][,][DELETE]}AS {SQL语句 [,... n]}</code></pre><p>删除DML触发器的语法：</p><pre><code>DROP TRIGGER 触发器名 [,... n]</code></pre><p>创建和修改DLL触发器发的语法：</p><pre><code>{CREATE|ALTER} TRIGGER 触发器名ON {DATABASE|ALL SERVER}[WITH DLL触发器选项 [,... n]]{FOR|AFTER} {触发事件名称|触发事件分组名称} [,... n]AS {SQL语句 [,... n]}</code></pre><p>其中常见的数据库作用域的DLL语句和服务器作用域的DLL语句见P315。</p><p>删除DLL触发器的语法：</p><pre><code>DROP TRIGGER 触发器名 [,... n]ON {DATABASE|ALL SERVER}</code></pre><p>启用和禁用触发器的语法：</p><pre><code>{ENABLE|DISABLE} TRIGGER {[模式名.]触发器名 [,... n]|ALL}ON {表名|视图名|DATABASE|ALL SERVER}</code></pre><h2><span id="第十一章-数据库安全">第十一章 数据库安全</span></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;《数据库原理与应用——SQL Server 2016版本》 主编：邓立国 佟强 清华大学出版社 2017年9月第1版 TP311.138 ISBN: 978-7-302-48305-2 &lt;/strong&gt;&lt;br&gt;本书系统地讲述数据库原理与SQL Server 2016的功能、应用及实践知识，包括关系数据库知识、数据库创建与维护、数据库表的操作管理及维护、完整性控制、查询与管理表数据、Transaction-SQL编程、存储过程和触发器、数据库安全管理、数据库系统开发配置连接等知识。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="note" scheme="http://yoursite.com/categories/note/"/>
    
    
      <category term="database" scheme="http://yoursite.com/tags/database/"/>
    
      <category term="sql server" scheme="http://yoursite.com/tags/sql-server/"/>
    
  </entry>
  
  <entry>
    <title>Profibus和Profinet通信协议</title>
    <link href="http://yoursite.com/2018/05/04/knowledge/know-profi/"/>
    <id>http://yoursite.com/2018/05/04/knowledge/know-profi/</id>
    <published>2018-05-04T07:52:05.000Z</published>
    <updated>2018-05-17T00:22:27.700Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/04/knowledge/know-profi/logo.jpg" alt="pi-logo"></p><p><a href="https://www.profibus.com/" target="_blank" rel="noopener">https://www.profibus.com/</a></p><p><strong>Profibus(Process Field Bus，过程现场总线)</strong>是一种国际化、开放式、不依赖于设备生产商的现场总线标准</p><p><strong>Profinet(Process Field Net, )</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/05/04/knowledge/know-profi/logo.jpg&quot; alt=&quot;pi-logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.profibus.com/&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="protocol" scheme="http://yoursite.com/tags/protocol/"/>
    
      <category term="industrial network" scheme="http://yoursite.com/tags/industrial-network/"/>
    
      <category term="field bus" scheme="http://yoursite.com/tags/field-bus/"/>
    
  </entry>
  
  <entry>
    <title>Modbus通信协议</title>
    <link href="http://yoursite.com/2018/05/03/knowledge/know-modbus/"/>
    <id>http://yoursite.com/2018/05/03/knowledge/know-modbus/</id>
    <published>2018-05-03T07:30:26.000Z</published>
    <updated>2018-05-17T00:28:20.180Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/03/knowledge/know-modbus/th.jpg" alt="modbus-logo"></p><h3><span id="modbus历史">Modbus历史</span></h3><p><strong>Modbus协议</strong>最早由Modicon公司（现为施耐德电气公司的品牌）于1979年开发，旨在实现可编程控制器(PLC)之间的通信，后逐渐被大多数公司认可，成为事实上的标准协议，是<strong>全球第一个真正用于工业现场的总线协议</strong>。<br>该公司后来还推出增强型Modbusplus(MB+)协议，完整定义了通信协议、网络结构、线缆等，是典型的令牌环网，与Modbus差异较大。<br>2004年起施耐德电气已将Modbus协议的所有权移交并成立了<strong><a href="http://modbus.org/" target="_blank" rel="noopener">Modbus组织</a></strong>，为之后的发展奠定了基础。在中国，Modbus已经成为国家标准GB/T19582-2008。</p><h3><span id="modbus概述">Modbus概述</span></h3><p>Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型，协议本身没有定义物理层，只是定义了消息帧格式、描述了设备请求和返回数据的过程以及侦测错误的手段等。在现实使用中，可以通过网关将串行链路(RS232/RS485)和以太网等不同物理连接网络通过Modbus协议组成统一的系统。<br><img src="/2018/05/03/knowledge/know-modbus/tcp-structure.JPG" alt="modbus-unified"></p><p><strong>Modbus协议栈</strong>主要包括<a href="http://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf" target="_blank" rel="noopener">Modbus应用层协议</a>、<a href="http://modbus.org/docs/Modbus_over_serial_line_V1_02.pdf" target="_blank" rel="noopener">Modbus串行链路协议</a>和<a href="http://modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf" target="_blank" rel="noopener">Modbus在以太网上的映射</a>，相应的规范可点击链接下载。<br><img src="/2018/05/03/knowledge/know-modbus/stack2.JPG" alt="modbus-stack"></p><h3><span id="modbus应用层协议">Modbus应用层协议</span></h3><p>Modbus应用层协议(OSI L7)规定了与下层实现无关的<strong>协议数据单元</strong>(Protocol Data Unit, PDU)，Modbus协议在某种总线或网络上的映射定义了<strong>应用数据单元</strong>(Application Data Unit, ADU)。不论是Modbus串行链路协议、以太网协议还是其他由Modbus衍生的协议，协议数据单元PDU都由<strong>功能代码段</strong>和<strong>数据段</strong>组成，数据段可以不存在。<br><img src="/2018/05/03/knowledge/know-modbus/general-pdu.JPG" alt="modbus-pdu"></p><h4><span id="请求回应模型">请求——回应模型</span></h4><p>在上层协议中，发出请求的一方为客户端Client，响应的一方为服务端Server。<br>在客户端发出请求消息中，功能代码告知服务端要执行何种功能。数据段包含了服务端要执行功能的任何附加信息。<br>如果服务端产生正常的回应，则返回相同的功能代码给客户端，数据段包括了服务端收集的数据；如果有错误发生，服务端将功能代码的MSB置1返回给客户端，同时数据段包含了描述此错误信息的代码。</p><h4><span id="数据编码和类型">数据编码和类型</span></h4><p>采用<strong>高字节序</strong>(Big-Endian)，即高字节先发送、低字节后发送。<br>Modbus协议中只有两种数据类型，即位bit和字word(16-bit)，根据访问类型分为以下四种：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">访问</th><th style="text-align:left">内容</th></tr></thead><tbody><tr><td style="text-align:center">离散量输入(Discrete Input)</td><td style="text-align:center">位bit</td><td style="text-align:center">只读</td><td style="text-align:left">IO系统提供这种类型数据</td></tr><tr><td style="text-align:center">线圈(Coil)</td><td style="text-align:center">位bit</td><td style="text-align:center">读写</td><td style="text-align:left">通过应用程序改变这种类型数据</td></tr><tr><td style="text-align:center">输入寄存器(Input Register)</td><td style="text-align:center">字word</td><td style="text-align:center">只读</td><td style="text-align:left">IO系统提供这种类型数据</td></tr><tr><td style="text-align:center">保持寄存器(Holding Register)</td><td style="text-align:center">字word</td><td style="text-align:center">读写</td><td style="text-align:left">通过应用程序改变这种类型数据</td></tr></tbody></table><p>地址寻址从0开始，详细的设备地址映射参见具体设备手册。</p><h4><span id="功能代码">功能代码</span></h4><p>功能代码段占用1个字节，取值范围为1-255，其中128-255为保留值，用于异常消息应答报文（原功能代码MSB置1）；1-127为功能代码编号，其中65-72和100-110为用户自定义功能代码，其余取值为通用功能代码。<strong>通用功能代码</strong>(Public Function Code)是已经公布的功能代码，由确定的功能，用户不能修改。<br>常用的通用功能代码如下：<br><img src="/2018/05/03/knowledge/know-modbus/pfc.JPG" alt="modbus-func-code">详细用法见<a href="http://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf" target="_blank" rel="noopener">Modbus应用层协议</a>。</p><h3><span id="modbus串行链路协议">Modbus串行链路协议</span></h3><p>Modbus针对串行链路的协议规定了通信的物理层和数据链路层(OSI L1/2)。物理层采用多种物理接口，最常用的是EIA/TIA-485双线接口。</p><h4><span id="主从模式">主从模式</span></h4><p>数据链路层采用<strong>主从通信模式(Master/Slave)</strong>，只有一个主设备可以初始化通信，并对总线上所有从设备进行控制。</p><ul><li>所有通信由主设备发出，从设备只能对主设备进行响应，互相不允许直接通信。</li><li>主设备对应上层协议中的客户端，从设备对应上层协议中的服务端。</li></ul><p>在<strong>单播模式</strong>(Unicast Mode)中，主设备发送请求至某个特定的从设备，从设备接到请求后进行应答并把消息反馈给主设备；在<strong>广播模式</strong>(Broadcast Mode)中，主设备可同时向多个从设备发送请求（设备地址0），从设备对广播请求不进行响应。<br>对于串行链路，应用数据单元ADU最大长度为256字节，协议数据单元PDU最大长度为253字节。<br>由于主站一次只能读取一个从站的数据，Modbus通信采用轮询方式，用在实时性要求较低的场合。</p><h4><span id="报文格式">报文格式</span></h4><p>串行链路的通用Modbus报文（消息帧）形式如下：<br><img src="/2018/05/03/knowledge/know-modbus/g1.JPG" alt="modbus-frame"><br><strong>1. Modbus-RTU</strong></p><ul><li>该模式中直接发送二进制数据流，以至少3.5个字符时间的停顿间隔分隔两帧，作为两帧开始和终止的标志，整个消息帧必须为连续的传输流，同一帧的两个数据间隔不能超过1.5个字符时间</li><li>在传输过程中需要定时器，从设备不断侦测总线及停顿间隔，当第一个域（即地址域）接收到，每个从设备都进行解码以判断是否发给自己</li><li>数据校验采用CRC（循环冗余校验），详见<a href="/2018/05/14/knowledge/know-crc/" title="CRC循环冗余校验码">CRC循环冗余校验码</a></li><li>地址域1个字节，功能代码1个字节，CRC校验2个字节，数据至多为252字节</li></ul><p><strong>2. Modbus-ASCII</strong></p><ul><li>该模式中消息的每个字节用16进制表示0x00-0xff，转化为两个ASCII字符进行发送，可以使用的传输字符是0-9、A-F，消息帧以字符”:”(ASCII码3A)作为起始符，以回车换行符(ASCII码0D,0A)作为终止符，同一帧的两个数据间隔可至多达到1s</li><li>在传输过程中不需要定时器，从设备不断侦测”:”字符，当接收到时每个设备都解码下个域（即地址域）来判断是否发给自己</li><li>数据校验采用LRC（纵向冗余校验），检测消息帧中除了开始符和终止符外的内容</li><li>起始符1个字节，地址域2个字节，功能代码2个字节，LRC校验2个字节，终止符2个字节，数据至多为2*252字节</li><li>该模式也称为命令行模式，由于发送的是可视化字符串，调试简便，但该模式传输效率较低</li></ul><h3><span id="modbus以太网协议">Modbus以太网协议</span></h3><p>基于Modbus协议进行以太网传输有多种形式，官方文档中给出的是基于Ethernet TCP/IP的Modbus TCP/IP（即Modbus-TCP），定义了TCP传输的报文格式以及<strong>默认端口号502</strong>。除此之外还有Modbus over TCP/IP（将Modbus-RTU/ASCII报文作为TCP数据包）、Modbus UDP/IP、Modbus over UDP/IP等非标准变体。</p><h4><span id="modbus-tcp报文格式">Modbus-TCP报文格式</span></h4><p>Modbus-TCP报文（消息帧）形式如下：<br><img src="/2018/05/03/knowledge/know-modbus/g3.JPG" alt="modbus-frame">数据以类似Modbus-RTU的二进制数据流发送。由于Ethernet TCP/IP数据链路层的校验机制保证了数据的完整性，报文中不含有数据校验，也没有地址域。同时Modbus-TCP加入了4个域、7个字节的报文头来识别应用数据单元ADU，称为<strong>MBAP报文头</strong>(Modbus Application Protoco Header)，具体形式如下：<br><img src="/2018/05/03/knowledge/know-modbus/MBAP_header.JPG" alt="modbus-tcp-header"></p><ol><li>事务处理标识符：用于事务处理配对，在响应中服务端复制请求的事务处理标识符</li><li>协议标识符：用于系统内多路复用，通过值0识别Modbus协议</li><li>长度：单元标识符和PDU的长度</li><li>单元标识符：用于以太网和串行链路间的网关对串行链路从站的通信</li></ol><h4><span id="modbus-rtps">Modbus-RTPS</span></h4><p>To be continued…</p><p>More <a href="http://www.modbustools.com/" target="_blank" rel="noopener">Modbus库和仿真软件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/05/03/knowledge/know-modbus/th.jpg&quot; alt=&quot;modbus-logo&quot;&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;modbus历史&quot;&gt;Modbus历史&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Modbus协
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="protocol" scheme="http://yoursite.com/tags/protocol/"/>
    
      <category term="industrial network" scheme="http://yoursite.com/tags/industrial-network/"/>
    
      <category term="field bus" scheme="http://yoursite.com/tags/field-bus/"/>
    
  </entry>
  
  <entry>
    <title>DNS域名系统与localhost</title>
    <link href="http://yoursite.com/2018/05/03/knowledge/know-DNS&amp;localhost/"/>
    <id>http://yoursite.com/2018/05/03/knowledge/know-DNS&amp;localhost/</id>
    <published>2018-05-03T00:53:04.000Z</published>
    <updated>2018-05-15T01:18:43.919Z</updated>
    
    <content type="html"><![CDATA[<p><strong>DNS(Domain Name System，域名系统)</strong>在万维网上作为域名和IP地址相互映射的分布式数据库。通过域名得到对应IP地址的过程叫做<strong>域名解析</strong>。DNS协议运行在UDP协议之上，使用UDP端口号53。为保证服务的高可用性，DNS要求使用多台名称服务器冗余支持每个区域。</p><p>Reference <a href="https://baike.baidu.com/item/DNS/427444#reference-[4]-15346050-wrap" target="_blank" rel="noopener">百度百科</a></p><p><strong>localhost</strong>是一个域名，在windows中该域名是由/etc/hosts文件预定义的，默认对于ipv4指向127.0.0.1，对于ipv6指向::1，可对hosts文件进行修改配置为任意的IP地址，但可能导致只认127.0.0.1的软件失效。</p><p>127.0.0.1/8整个都是环回(loopback)地址，用来测试本机的TCP/IP协议栈，以及本机中各个应用之间的网络交互，也称虚拟网卡。Windows中看不到这个接口，Linux中这个接口叫lo，可通过ifconfig查看。</p><p>本机IP地址一般指绑定在物理或虚拟接口上的IP地址，供其他设备访问。</p><p>Reference <a href="https://www.zhihu.com/question/23940717" target="_blank" rel="noopener">知乎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;DNS(Domain Name System，域名系统)&lt;/strong&gt;在万维网上作为域名和IP地址相互映射的分布式数据库。通过域名得到对应IP地址的过程叫做&lt;strong&gt;域名解析&lt;/strong&gt;。DNS协议运行在UDP协议之上，使用UDP端口号53。
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="network basis" scheme="http://yoursite.com/tags/network-basis/"/>
    
  </entry>
  
  <entry>
    <title>NTP网络时间协议</title>
    <link href="http://yoursite.com/2018/04/28/knowledge/know-NTP/"/>
    <id>http://yoursite.com/2018/04/28/knowledge/know-NTP/</id>
    <published>2018-04-28T08:55:35.000Z</published>
    <updated>2018-05-15T01:18:41.632Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NTP(Network Time Protocol，网络时间协议)</strong>是用来同步网络中各个计算机时间的协议，属于应用层协议，采用UDP报文传输，使用UDP端口号为123。连接到互联网上的主机通过NTP与UTC(Universal Time Coordinate，世界协调时)同步，UTC由原子钟报时。<br>计算机主机一般同多个时钟服务器连接，利用统计学的算法过滤来自不同服务器的时间，选择最佳的路径和来源以便校正主机时间。</p><p>Reference <a href="https://baike.baidu.com/item/nTP" target="_blank" rel="noopener">百度百科</a><br>More <a href="http://blog.163.com/yzc_5001/blog/static/2061963420121283050787/" target="_blank" rel="noopener">sms的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;NTP(Network Time Protocol，网络时间协议)&lt;/strong&gt;是用来同步网络中各个计算机时间的协议，属于应用层协议，采用UDP报文传输，使用UDP端口号为123。连接到互联网上的主机通过NTP与UTC(Universal Time Co
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="network basis" scheme="http://yoursite.com/tags/network-basis/"/>
    
      <category term="protocol" scheme="http://yoursite.com/tags/protocol/"/>
    
  </entry>
  
  <entry>
    <title>修改虚拟机启动时间</title>
    <link href="http://yoursite.com/2018/04/28/tip/tip-vm-time/"/>
    <id>http://yoursite.com/2018/04/28/tip/tip-vm-time/</id>
    <published>2018-04-28T06:51:56.000Z</published>
    <updated>2018-05-15T01:16:25.873Z</updated>
    
    <content type="html"><![CDATA[<p>由于软件license的时间限制，需要用过去的时间启动虚拟机。</p><ol><li>修改主机时间。启动虚拟机后系统时间即当前主机时间。但在主机中打开Chrome浏览器会报错，提示时钟慢了，无法建立私密连接。</li><li>修改虚拟机启动时间。用文本编辑器打开虚拟机.vmx文件，寻找以下设置项并关闭同步，设置虚拟机启动时间，保存后启动虚拟机。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tools.syncTime = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.continue = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.restore = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.resume.disk = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.shrink = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.tools.startup = &quot;FALSE&quot; </span><br><span class="line">rtc.startTime = 1462003200</span><br></pre></td></tr></table></figure></li></ol><p>注：rtc.startTime是从1970年1月1日0时0分0秒（Unix时间）到系统启动时间间隔的时间，单位是秒，可以到<a href="http://www.onlineconversion.com/unix_time.htm" target="_blank" rel="noopener">计算时间的网站</a>上换算得到希望虚拟机的启动时间。</p><p>Reference <a href="https://blog.csdn.net/sagafive/article/details/53031740" target="_blank" rel="noopener">SagaFive的专栏</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于软件license的时间限制，需要用过去的时间启动虚拟机。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改主机时间。启动虚拟机后系统时间即当前主机时间。但在主机中打开Chrome浏览器会报错，提示时钟慢了，无法建立私密连接。&lt;/li&gt;
&lt;li&gt;修改虚拟机启动时间。用文本编辑器打开虚拟机
      
    
    </summary>
    
      <category term="tip" scheme="http://yoursite.com/categories/tip/"/>
    
    
      <category term="virtual machine" scheme="http://yoursite.com/tags/virtual-machine/"/>
    
  </entry>
  
  <entry>
    <title>使用C#编写OPC程序</title>
    <link href="http://yoursite.com/2018/04/28/experience/exp-cs-opc/"/>
    <id>http://yoursite.com/2018/04/28/experience/exp-cs-opc/</id>
    <published>2018-04-28T01:23:59.000Z</published>
    <updated>2018-04-28T01:51:43.505Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://opcfoundation.org/" target="_blank" rel="noopener">OPC基金会官网</a>真是弱爆了。</p><h3><span id="1-配置opcdaautodll">1. 配置OPCDAAuto.dll</span></h3><p>OPC的自动化接口即OPCDAAuto.dll<br>1)下载文件OPCDAAuto.dll，版本2.2.5.30<br>2)放到System32文件夹下，用管理员身份打开cmd<br>3)输入regsvr32 opcdaauto.dll后提示成功<br>4)打开Visual Studio在项目中打开相应项目，对解决方案右键-添加-引用，浏览选择opcdaaturo.dll<br>5)依赖项中出现COM-Interop.OPCAutomation，在C#程序开头using OPCAutomation；不再显示红色波浪线错误，即配置成功。</p><p>Reference <a href="https://blog.csdn.net/u012252959/article/details/49699559" target="_blank" rel="noopener">u012252959的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://opcfoundation.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OPC基金会官网&lt;/a&gt;真是弱爆了。&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;1-配置opcdaautodll&quot;&gt;1. 配置OPCDAAuto
      
    
    </summary>
    
      <category term="experience" scheme="http://yoursite.com/categories/experience/"/>
    
    
      <category term="OPC" scheme="http://yoursite.com/tags/OPC/"/>
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Learning hard C#学习笔记》笔记</title>
    <link href="http://yoursite.com/2018/04/28/note/note-cs/"/>
    <id>http://yoursite.com/2018/04/28/note/note-cs/</id>
    <published>2018-04-28T00:55:46.000Z</published>
    <updated>2018-05-28T08:47:32.431Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#第一章-基础知识">第一章 基础知识</a></li><li><a href="#第八章-委托">第八章 委托</a></li><li><a href="#第九章-事件">第九章 事件</a></li></ul><!-- tocstop --><p>《Learning hard C#学习笔记》 李志 人民邮电出版社<br><a id="more"></a></p><h2><span id="第一章-基础知识">第一章 基础知识</span></h2><p>C#</p><h2><span id="第八章-委托">第八章 委托</span></h2><p><strong>委托</strong>是C#中最中需要的特性之一，它使得C#中的函数可以作为参数被传递，与C/C++中的函数指针类似。它是一个特殊的类，所有的委托都是从System.MulticastDelegate类派生的。<br>委托的定义和方法的定义类似，只是在定义前多了一个delegate关键字：</p><pre><code>访问修饰符 delegate 返回类型 委托名([参数表])</code></pre><p>能被委托包装的方法需要满足：</p><ol><li>方法的签名与委托一致（参数个数、类型、顺序）</li><li>方法的返回类型与委托一致</li></ol><p>委托也可以封装多个方法，称为<strong>委托链</strong>或多路广播委托，在委托链上的委托都会被顺序执行。可以通过“+”运算符把委托链接到一个委托对象实例上，也可以使用“-”运算符将某个委托从委托链对象上移除。</p><div><div class="fold_hider"><div class="close hider_title">委托和委托链的例子（点击显示代码）</div></div><div class="fold"><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSbook</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//委托的定义</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params">MyDelegate mydelegate</span>)</span>&#123;</span><br><span class="line">            mydelegate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            MyDelegate m = <span class="keyword">new</span> MyDelegate(Program.Mult);</span><br><span class="line">            <span class="comment">// 方法Program.Mult作为方法MyMethod的参数</span></span><br><span class="line">            MyMethod(m);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            MyDelegate p = <span class="keyword">new</span> MyDelegate(<span class="keyword">new</span> Program().Add);</span><br><span class="line">            MyDelegate q = <span class="keyword">new</span> MyDelegate(<span class="keyword">new</span> Program().Sub);</span><br><span class="line">            MyDelegate chain = <span class="literal">null</span>;</span><br><span class="line">            chain += m;</span><br><span class="line">            chain += p;</span><br><span class="line">            chain += q;</span><br><span class="line">            chain -= m;</span><br><span class="line">            chain(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实例方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = para1 + para2;</span><br><span class="line">            Console.WriteLine(<span class="string">"Sum is: "</span> + sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Sub</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sub = para1 - para2;</span><br><span class="line">            Console.WriteLine(<span class="string">"Sub is: "</span> + sub);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mult</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mul = para1 * para2;</span><br><span class="line">            Console.WriteLine(<span class="string">"Mul is: "</span> + mul);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2><span id="第九章-事件">第九章 事件</span></h2>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#第一章-基础知识&quot;&gt;第一章 基础知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#第八章-委托&quot;&gt;第八章 委托&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#第九章-事件&quot;&gt;第九章 事件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;《Learning hard C#学习笔记》 李志 人民邮电出版社&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="note" scheme="http://yoursite.com/categories/note/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="programming language" scheme="http://yoursite.com/tags/programming-language/"/>
    
  </entry>
  
  <entry>
    <title>FactoryTalk Transaction Manager使用心得</title>
    <link href="http://yoursite.com/2018/04/27/experience/exp-trans-1/"/>
    <id>http://yoursite.com/2018/04/27/experience/exp-trans-1/</id>
    <published>2018-04-27T09:03:46.000Z</published>
    <updated>2018-05-17T01:57:43.022Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="基本概念">基本概念</span></h2><p><strong>FactoryTalk Transaction Manager</strong>（前身是RSSql）是Rockwell公司FactoryTalk系列组态软件之一，主要实现工控系统与数据库的通信，该系列软件基于<a href="https://baike.baidu.com/item/SOA/2140650" target="_blank" rel="noopener">SOA架构</a>开发，因此Transaction Manager应用软件部分实际上是对各个数据传送服务进行配置的UI界面，该软件的核心实际上是各个接口的服务程序。<br><a id="more"></a></p><p><img src="/2018/04/27/experience/exp-trans-1/structure.JPG" alt="structure"></p><p>Transaction and Control Manager服务包含了Transaction Manager Service服务和FactoryTalk Live Data控制接口，可以通过该服务连接Rockwell软件和所有OPC服务器。</p><p>启动操作系统后查看服务列表，可以看到Transaction Manager相关的各个服务。</p><p><img src="/2018/04/27/experience/exp-trans-1/services.png" alt="services"></p><p>FactoryTalk Transaction Manager可以使用以下<strong>控制接口</strong>(control connector)，来关联数据点(data point)或存储地址(memory location)：</p><ol><li>FactoryTalk Live Data</li><li>Dynamic Data Exchange (DDE)</li><li>RSLinx Classic OPC</li><li>RSView32</li><li>Generic OPC</li></ol><p>FactoryTalk Transaction Manager可以使用以下<strong>企业接口</strong>(enterprise connector)，来创建数据对象(data object)与企业系统中的数据表(database table)和预存过程(stored procedure)进行交互：</p><ol><li>Open Database Connectivity (ODBC)</li><li>Microsoft OLE DB</li><li>Microsoft COM+</li><li>Oracle Call Interface (OCI)</li><li>Time-series Data Compression</li><li>FactoryTalk Metrics connector</li></ol><!-- ## 1. OPC Server -> SQL Server ##OPC Server: KEPSever Enterprise 5.13SQL Server: Microsoft SQL Server 2008 R2## 2. Live Data -> SQL Server## 3. SQL Server -> Live Data -->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;FactoryTalk Transaction Manager&lt;/strong&gt;（前身是RSSql）是Rockwell公司FactoryTalk系列组态软件之一，主要实现工控系统与数据库的通信，该系列软件基于&lt;a href=&quot;https://baike.baidu.com/item/SOA/2140650&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SOA架构&lt;/a&gt;开发，因此Transaction Manager应用软件部分实际上是对各个数据传送服务进行配置的UI界面，该软件的核心实际上是各个接口的服务程序。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="experience" scheme="http://yoursite.com/categories/experience/"/>
    
    
      <category term="OPC" scheme="http://yoursite.com/tags/OPC/"/>
    
      <category term="FactoryTalk" scheme="http://yoursite.com/tags/FactoryTalk/"/>
    
      <category term="Rockwell" scheme="http://yoursite.com/tags/Rockwell/"/>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>《OPC应用程序入门》笔记</title>
    <link href="http://yoursite.com/2018/04/27/note/note-opc/"/>
    <id>http://yoursite.com/2018/04/27/note/note-opc/</id>
    <published>2018-04-27T02:06:54.000Z</published>
    <updated>2018-05-25T05:13:28.650Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#第一章-opc基础知识">第一章 OPC基础知识</a><ul><li><a href="#11-什么是opc">1.1 什么是OPC</a></li></ul></li></ul><!-- tocstop --><p>《OPC应用程序入门》<br><a id="more"></a></p><p><img src="/2018/04/27/note/note-opc/ch1-1.PNG" alt="ch1-1"></p><h2><span id="第一章-opc基础知识">第一章 OPC基础知识</span></h2><h3><span id="11-什么是opc">1.1 什么是OPC</span></h3><p><strong>OPC</strong>(OLE for Process Control)是为不同供应商设备和应用程序之间的软件接口标准化而提出的，使其间的数据交换不依赖于特定开发语言和开发环境。它利用Windows中的OLE/COM技术实现<strong>工业制造系统过程控制中数据交换的标准化</strong>。OPC系统由提供数据收集服务的<strong>OPC服务器</strong>(OPC Server)、接受数据服务的<strong>OPC应用程序</strong>(OPC Client)和<strong>OPC接口</strong>所构成。</p><p>在OPC技术出现以前，<strong>DDE</strong>（Dynamic Data Exchange）技术曾经对过程控制做出巨大贡献，但是DDE是基于Windows信息传递而建立的技术，存在诸多问题。OPC基于<strong>COM</strong>（组件对象模型，Component Object Model）和<strong>DCOM</strong>（分布式COM）技术开发，实际上OPC是为工业标准定义的特殊的COM接口，与DDE相比在速度、分布式安全管理、开发成本、可靠性等方面都具有优势。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#第一章-opc基础知识&quot;&gt;第一章 OPC基础知识&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-什么是opc&quot;&gt;1.1 什么是OPC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;《OPC应用程序入门》&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="note" scheme="http://yoursite.com/categories/note/"/>
    
    
      <category term="OPC" scheme="http://yoursite.com/tags/OPC/"/>
    
  </entry>
  
  <entry>
    <title>Scala和Spark学习总结</title>
    <link href="http://yoursite.com/2017/08/01/Scala%E5%92%8CSpark%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/08/01/Scala和Spark学习总结/</id>
    <published>2017-08-01T07:03:26.000Z</published>
    <updated>2018-05-25T07:07:44.800Z</updated>
    
    <content type="html"><![CDATA[<p>在两个多月的实习时间里，我学习并掌握了Hive、Scala、Spark的基本用法，并将它们用在处理大规模的LBS数据来完成用户家庭、工作地址预测和POI信息关联及推荐等任务。期间遇到了很多坑，慢慢摸索之后才把它们都处理好。<a id="more"></a></p><h2><span id="学习资料推荐">学习资料推荐</span></h2><h3><span id="scala">Scala</span></h3><ul><li><a href="http://docs.scala-lang.org" target="_blank" rel="noopener">网站-Scala官方文档</a></li><li><a href="https://book.douban.com/subject/26826535/" target="_blank" rel="noopener">书籍-Scala编程实战</a></li><li><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">编程环境-IDEA及其Scala插件</a></li></ul><h3><span id="spark">Spark</span></h3><ul><li><a href="http://spark.apache.org/docs/latest/" target="_blank" rel="noopener">网站-Spark官方文档</a></li><li><a href="https://book.douban.com/subject/26616244/" target="_blank" rel="noopener">书籍-Spark快速大数据分析</a></li><li><a href="https://spark-packages.org" target="_blank" rel="noopener">网站-Spark第三方包索引</a></li></ul><h2><span id="遇到的坑">遇到的坑</span></h2><p>在应用的过程中，由于自己学习时间并不长，很多细节没有太注意，经验也不足，遇到了一些坑，大多数在网上搜索一番后找到了解决办法。我把它们一个个罗列在下面。</p><h3><span id="0广播变量broadcast与app特质的bug">#0:广播变量Broadcast与App特质的Bug</span></h3><p>这个bug的描述和解决方法参见<a href="https://stackoverflow.com/questions/31303827/spark-broadcasted-variable-returns-nullpointerexception-when-run-in-amazon-emr-c" target="_blank" rel="noopener">这里</a>。广播变量在Spark中是用来将你的变量发送到集群的各个工作节点上以便被它们使用。App特质是Scala中比较常用的特质，定义好了很多实用的方法，如计时器，而且不用定义主函数，object本身即是主函数。但是这两个特性合起来就会出问题，如果使用了App特质，那么程序中的广播变量就会不起作用，解决办法就是不使用App特质。</p><h3><span id="1scala中的case-class的equals方法与普通class不同">#1:Scala中的case class的equals方法与普通class不同</span></h3><p>这个细节问题是我在改写GitHub上的DBSCAN算法的代码时发现的。为了防止算法在处理大规模数据时会出现内存耗尽的问题，我需要使用集合Set来判断现在处理的数据点是否已经在Set中，防止重复添加大量相同的点到处理队列中导致内存耗尽。数据点是用case class定义的，初始定义代码如下：</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.mllib.linalg.<span class="type">Vector</span></span><br><span class="line"><span class="keyword">import</span> scala.math._</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">DBSCANPoint</span>(<span class="params">val vector: <span class="type">Vector</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">x</span> </span>= vector(<span class="number">0</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">y</span> </span>= vector(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">distanceSquared</span></span>(other: <span class="type">DBSCANPoint</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> dx = other.x - x</span><br><span class="line">    <span class="keyword">val</span> dy = other.y - y</span><br><span class="line">    (dx * dx) + (dy * dy)</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个DBSCANPoint是用case class定义的，参数是vector，而case class会帮你把诸如equals、toString、hashCode这些方法都按照一定的规范实现好。而当定义两个用相同的vector创建的DBSCANPoint实例时，用equals去比较两个实例时会返回true，因为它们的成员变量是相等的。但是如果在定义这个类不使用case class而使用普通的class，用equals去比较它们会返回false。但是我在处理LBS数据（即经纬度数据）时，会碰到很多经纬度一样的数据点，但是在算法处理它们时，并不能把它们看成同一个点，所以用上面这种方法定义DBSCANPoint就会出问题。我的解决办法就是在类的定义中添加一个id作为参数，这样就可以把经纬度相同的点给区分开来。</p><h3><span id="2rdd的first操作只会执行一个分区的转换操作">#2:RDD的first操作只会执行一个分区的转换操作</span></h3><p>由于Spark中的转化操作是采用惰性求值的机制(参见《Spark快速大数据分析》3.3.3），所以程序会在行动操作前将多个转化操作合并起来优化执行。但是当我们想去估计每个转化操作的时间时就不对了，因为当程序执行到转换操作时，其实它们并没有真正的执行，你在每个步骤之间用计时的函数去估计时间时就会发现每一步都很快，只有在行动操作时会消耗很长的时间。本应该使用collect这个执行操作去强制执行转换操作来估计时间，但是在出来大规模数据时collect操作很有可能会因为数据量太大，导致driver节点的内存被耗尽。所以我采用了first这个执行操作，本以为first这个操作也会强制执行前面的转化操作，但是后来我发现first操作只会对其中的一个partition执行转化操作，其他的分区并不会执行，因为我在log中发现，每次执行到first这一步骤的时候，都只有一个partition输出，无论我原来的RDD有多少分区，让我一度以为我的partition失败了。所以用first操作去强制执行转化操作来估计时间是不行的，后来我采用count操作来强制执行前面的转化操作，来估计每一个转化操作的时间。</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.compat.<span class="type">Platform</span>.currentTime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Code to create a rdd</span></span><br><span class="line"><span class="comment">  * /</span></span><br><span class="line"><span class="comment">var start = currentTime</span></span><br><span class="line"><span class="comment">val rdd2 = rdd.map(myMapFunction(_)).cache()</span></span><br><span class="line"><span class="comment">rdd2.count()</span></span><br><span class="line"><span class="comment">println(s"Time for map is $&#123;(currentTime-start).toDouble / 1000.0&#125; seconds.")</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3><span id="3java在spark中的函数传递方法">#3:Java在Spark中的函数传递方法</span></h3><p>虽然平常写的是Scala代码，但是有很多jar包都是用Java来编程和编译的，所以对Spark的Java API也要有所了解，相比Scala，Java（Java 8以前的版本，Java 8 引入了lambda表达式）就麻烦很多，需要实现 org.apache.spark.api.java.function包中的函数接口，见《Spark快速大数据分析》3.4.3。了解这些之后对理解Java版的Spark代码有很大帮助。</p><h3><span id="4spark-submit中client和cluster模式的区别">#4:spark-submit中client和cluster模式的区别</span></h3><p>在spark-submit命令中可以设定deploy-mode，有client和cluster模式，这两者之间的区别参见《Spark快速大数据分析》7.3的表7-2中的描述：在客户端（client）模式下，spark-submit会将驱动器程序运行在spark-submit被调用的这台机器上；在集群（cluster）模式下，驱动器程序会被传输并执行于集群的一个工作节点上。client模式的优势在于，程序运行的log都会在命令行窗口中显示出来，方便调试；而cluster模式下只能到Web UI中才能查看log，但是好处在于程序运行时，与本地的电脑没有任何关系，适合应用于生产环境。除了在deploy-mode参数中设置以外，还可以通过master参数设置，例如yarn-client或者yarn-cluster就代表这两种模式。</p><h3><span id="5默认的文件读取与保存的路径">#5:默认的文件读取与保存的路径</span></h3><p>在spark中读取某个文件时，默认是在hdfs上去找这个文件，例如textFile函数，如果路径参数是”./a.txt”，那么Spark会去”hdfs:///users/your_username/a.txt”这个路径上去读取文件，如果要让Spark在本地的目录读取文件，需要在路径前面加上”File://“,例如”File:///home/your_username/a.txt”。</p><h2><span id="spark学习笔记">Spark学习笔记</span></h2><h3><span id="hive和spark的接口">Hive和Spark的接口</span></h3><p>通常大规模数据都在集群上的数据仓库Hive中，数据庞大以至于我们不可能把数据都download到本地来处理，我们需要把Hive中的数据读取出来并转换成Spark可以操作的RDD，进行一系列处理，然后再把运行结果RDD转换成一个表保存起来。这就需要我们利用Spark和Hive的接口来进行这一系列操作，参见<a href="http://spark.apache.org/docs/latest/sql-programming-guide.html#hive-metastore-parquet-table-conversion" target="_blank" rel="noopener">官网教程</a>。</p><h4><span id="从hive中读取数据保存成rdd">从Hive中读取数据保存成RDD</span></h4> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="string">"Hive Spark Test"</span>).enableHiveSupport().getOrCreate()</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">import</span> spark.sql</span><br><span class="line">    sql(<span class="string">"use your_database"</span>)</span><br><span class="line">    <span class="keyword">val</span> df = sql(<span class="string">s"select * from your_table"</span>)</span><br><span class="line">    <span class="keyword">val</span> rdd = df.rdd</span><br><span class="line">    <span class="keyword">val</span> rdd2 = rdd.map(x =&gt; (x._1.toString, x._2.toString))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中rdd是一个RDD[Row]类型的变量，Row是一个tuple，这个RDD中的每一行就是原来表中的每一行，tuple在scala中是通过”._x”去索引的，x是从1开始的整数，这个数字代表数据是原来表中的第几列。</p><h4><span id="将rdd保存成hive表">将RDD保存成Hive表</span></h4> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *接上一小节代码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">val</span> schema = <span class="type">StructType</span>(<span class="type">Seq</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"Col_1"</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"Col_2"</span>, <span class="type">StringType</span>, <span class="literal">true</span>)))</span><br><span class="line">  <span class="keyword">val</span> rowRDD = rdd2.map(x =&gt; <span class="type">Row</span>(x._1, x._2))</span><br><span class="line">  <span class="keyword">val</span> result_df = spark.createDataFrame(rowRDD, schema)</span><br><span class="line">  result_df.registerTempTable(<span class="string">"tmp_table"</span>)</span><br><span class="line">  sql(<span class="string">"drop table if exists new_table"</span>)</span><br><span class="line">  sql(<span class="string">"create table if not exists new_table as select * from tmp_table"</span>)</span><br><span class="line">  sql(<span class="string">"select * from new_table"</span>).show()</span><br></pre></td></tr></table></figure><p>这个过程就是上一个过程的逆过程，把RDD通过一个schema转换成一个DataFrame，然后保存到Hive中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在两个多月的实习时间里，我学习并掌握了Hive、Scala、Spark的基本用法，并将它们用在处理大规模的LBS数据来完成用户家庭、工作地址预测和POI信息关联及推荐等任务。期间遇到了很多坑，慢慢摸索之后才把它们都处理好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="scala" scheme="http://yoursite.com/tags/scala/"/>
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
  </entry>
  
</feed>
