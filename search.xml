<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>CC-Link通信协议</title>
      <link href="/2018/05/16/knowledge/know-ccl/"/>
      <url>/2018/05/16/knowledge/know-ccl/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> industrial network - field bus - protocol </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CIP通信协议及其衍生</title>
      <link href="/2018/05/16/knowledge/know-cip/"/>
      <url>/2018/05/16/knowledge/know-cip/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protocol </tag>
            
            <tag> industrial network </tag>
            
            <tag> field bus </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>USS通用串行接口协议</title>
      <link href="/2018/05/14/knowledge/know-uss/"/>
      <url>/2018/05/14/knowledge/know-uss/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protocol </tag>
            
            <tag> USS </tag>
            
            <tag> serial communication </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CRC循环冗余校验码</title>
      <link href="/2018/05/14/knowledge/know-crc/"/>
      <url>/2018/05/14/knowledge/know-crc/</url>
      <content type="html"><![CDATA[<p><strong>循环码</strong>(Cyclic Redundancy Check, CRC)是一种检错率高、编码效率高的检错码，通过除法运算来建立有效信息位和校验位之间的约定关系。<br><a id="more"></a><br>CRC码由两部分组成，前部分是<strong>信息码</strong>，后部分是<strong>校验码</strong>，若CRC码总共长$n$位，信息码长$k$位，则称为<strong>$(n,k)$码</strong>，$r=n-k$即冗余位长度，也就是校验码长度。</p><p>基本概念：</p><ul><li>$n$位二进制码可以表示最高次幂为$n-1$的多项式。</li><li><strong>按位除</strong>（模2除）运算实际上就是在除的过程中做异或运算，同时不考虑进位，直到余数的位数小于除数时得到最终余数。在异或运算中模2减与模2加真值表完全相同。</li></ul><p>对于一个给定的$(n,k)$码，可以证明存在最高次幂为$r$的<strong>生成多项式</strong>$G(x)$，满足</p><ol><li>最高位和最低位为1</li><li>当被传送信息任何一位发生错误时，被生成多项式做模2除后使余数不为0</li><li>不同位发生错误时使余数不同</li><li>对余数继续做模2除应使余数循环</li></ol><p>将这些条件反映为数学关系是复杂的，常用的对应不同码制的生成多项式$G(x)$详见<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener">Wikipedia</a>：</p><ul><li>CRC1:  $x^1+x^0$</li><li>CRC4:  $x^4+x^1+x^0$</li><li>CRC8:  $x^8+x^5+x^4+x^0$</li><li>CRC12: $x^{12}+x^{11}+x^3+x^2+x^0$</li><li>CRC16: $x^{16}+x^{15}+x^2+x^0$</li></ul><p>具体<strong>编码规则</strong>如下。</p><ol><li>接收方和发送方约定发送组的信息位k和冗余位r个数，选定生成多项式$G(x)$满足上述条件</li><li>发送方将原始数据左移$r$位得到$M(x)$，随后按位除生成多项式$G(x)$，得到余数$R(x)$，有$\frac{M(x)}{G(x)}=Q(x)…R(x)$</li><li>发送方将$M(x)$与$R(x)$连接（等同于模2加或模2减）后一起发送</li><li>接收方将收到的数据按位除生成多项式$G(x)$，若余数为$0$则传输正确，若余数不为$0$则传输错误，即$\frac{M(x)+R(x)}{G(x)}=\frac{M(x)-R(x)}{G(x)}=Q(x)…0$</li></ol><p>CRC校验码可以检查出全部单个错、全部离散二位错、全部奇数个数、全部长度小等于$k$位的突发错，并以$1-(1/2)^{k-1}$概率检查出长度位$k+1$位的突发错。</p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> communication basis </tag>
            
            <tag> error-detecting code </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络传输电气知识</title>
      <link href="/2018/05/14/knowledge/know-networkelectric/"/>
      <url>/2018/05/14/knowledge/know-networkelectric/</url>
      <content type="html"><![CDATA[<p>数字表示网络数据传输速率，单位为Mbps；Base表示基带传输，即未经过调制、不能复用的传输，Broad表示宽带传输；-后面的字母或数字指传输介质。<br><a id="more"></a><br>IEEE标准共有以下几种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">传输介质</th><th style="text-align:center">传输距离</th><th style="text-align:center">连接器</th></tr></thead><tbody><tr><td style="text-align:center">10Base-5</td><td style="text-align:center">RG-8/RG-11同轴电缆（粗缆）</td><td style="text-align:center">500米</td><td style="text-align:center">AUI或MAU连接器</td></tr><tr><td style="text-align:center">10Base-2</td><td style="text-align:center">RG-58同轴电缆（细缆）</td><td style="text-align:center">185米</td><td style="text-align:center">BNC连接器</td></tr><tr><td style="text-align:center"><strong>10Base-T</strong></td><td style="text-align:center">CAT3非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">10Base-F</td><td style="text-align:center">光纤</td><td style="text-align:center">500米以上</td><td style="text-align:center">FP/FL/FB连接器</td></tr><tr><td style="text-align:center"><strong>100Base-TX</strong></td><td style="text-align:center">CAT5非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">100Base-T4</td><td style="text-align:center">CAT3非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">100Base-F</td><td style="text-align:center">光纤</td><td style="text-align:center">2000米</td><td style="text-align:center">SC</td></tr><tr><td style="text-align:center"><strong>1000Base-T</strong></td><td style="text-align:center">CAT5e非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center"><strong>1000Base-TX</strong></td><td style="text-align:center">CAT6非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">1000Base-CX</td><td style="text-align:center">屏蔽双绞线</td><td style="text-align:center">25米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">1000Base-LX</td><td style="text-align:center">单模光纤</td><td style="text-align:center">3000米</td><td style="text-align:center">SFP</td></tr><tr><td style="text-align:center">1000Base-SX</td><td style="text-align:center">多模光纤</td><td style="text-align:center">300-550米</td></tr></tbody></table></div><p><strong>双绞线</strong>把两根22-26号绝缘铜导线按一定密度互相绞在一起，每一根导线在传输中辐射出来的电波会被另一根线上发出的电波抵消，有效降低信号干扰的程度。与其他传输介质相比，双绞线在传输距离，信道宽度和数据传输速度等方面均受到一定限制，但价格较为低廉，应用非常广泛。<br><strong>屏蔽双绞线</strong>在双绞线与外层绝缘封套之间有一个金属屏蔽层。<strong>STP</strong>(Shielded Twisted Pair)指每条线都有各自的屏蔽层，而<strong>FTP</strong>(Foil Twisted Pair)只在整个电缆有屏蔽装置，并且两端都正确接地时才起作用。屏蔽层可减少辐射，防止信息被窃听，也可阻止外部电磁干扰，屏蔽双绞线比同类的非屏蔽双绞线具有更高的传输速率。<br><strong>非屏蔽双绞线UTP</strong>(Unshielded Twisted Pair)直径小、成本低、易弯曲、易安装，广泛用于以太网和电话线中。常见的非屏蔽双绞线由4对8根不同颜色的传输线组成。<br><img src="/2018/05/14/knowledge/know-networkelectric/twisted_pair.jpg" alt="twisted pair"><br>按照频率带宽和信噪比双绞线可以分为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">最高频率带宽</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:center">CAT1</td><td style="text-align:center">750kHz</td><td style="text-align:left">用于报警系统，不用于数据传输</td></tr><tr><td style="text-align:center">CAT2</td><td style="text-align:center">1MHz</td><td style="text-align:left">用于语音传输和最高4Mbps的数据传输</td></tr><tr><td style="text-align:center">CAT3</td><td style="text-align:center">16MHz</td><td style="text-align:left">用于10Base-T以太网和4Mbps令牌环</td></tr><tr><td style="text-align:center">CAT4</td><td style="text-align:center">20MHz</td><td style="text-align:left">用于局域10Base-T/100Base-T以太网和16Mbps令牌环</td></tr><tr><td style="text-align:center"><strong>CAT5</strong></td><td style="text-align:center">100MHz</td><td style="text-align:left">用于10Base-T/100Base-T网络</td></tr><tr><td style="text-align:center">CAT5e</td><td style="text-align:center">100MHz</td><td style="text-align:left">用于1000Base-T网络</td></tr><tr><td style="text-align:center">CAT6</td><td style="text-align:center">250MHz</td><td style="text-align:left">用于最高1Gbps的数据传输</td></tr><tr><td style="text-align:center">CAT6A</td><td style="text-align:center">500MHz</td><td style="text-align:left">用于最高10Gbps的数据传输</td></tr><tr><td style="text-align:center">CAT7</td><td style="text-align:center">600MHz</td><td style="text-align:left">用于最高10Gbps的数据传输</td></tr></tbody></table></div><p>目前最常用的为CAT5和CAT6，CAT6以上的产品国家未出台正式检测标准。电话线接口常用RJ11连接器，网线接口常用RJ45连接器，都称为水晶头。</p><p>EIA/TIA标准规定了两种双绞线线序T568A和T568B，常用网线分为<strong>直连互联</strong>和<strong>交叉互联</strong>两种接法。<br>可以看作<strong>数据终端设备</strong>(Data Terminal Equipment, DTE)的有电脑、路由器、交换机uplink口、HUB级联口等，可以看<strong>数据电路终接设备</strong>(Data Circuit-terminating Equipment, DCE)的有交换机普通口、HUB普通口等。同类设备间相连使用交叉线方式，异类设备间相连使用直通线方式。现在的交换机通常具有端口自动翻转功能，因此对直通线和交叉线不加以区分。<br><img src="/2018/05/14/knowledge/know-networkelectric/utp&amp;stp.jpg" alt="twisted pair"></p><p><strong>单模光纤</strong>中心的玻璃芯很细，只能传播一种模式的光信号，在单模光纤中光沿直线传播，无反射，传播距离非常远，一般为黄色。<strong>多模光纤</strong>芯径较大，可以传输多种模式的光信号，一般为橘红色或灰色，不同模光进入光纤的角度不同，它们到达另一端的时间也不同，称为<strong>模分散</strong>，模分散技术限制了多模光纤的带宽和距离。<br><img src="/2018/05/14/knowledge/know-networkelectric/optical_fiber.JPG" alt="twisted pair"></p><p>常见的光纤接口包括SC（方形卡接式）、LC（圆形小）、DLC（圆形小双头）、FC（圆形带螺纹）、ST（圆形卡接式）和MTRJ（方形双头）等，插芯研磨平面又可以分为PC、UPC、APC等。<br><strong>光电转换器</strong>又称光纤收发器，是一种将短距离电信号和长距离光信号进行互换的设备，目前最常用的光电转换器为热插拔小封装模块(Small Form-factor Pluggables, SFP)，具有体积小、端口多等优点，多采用LC接口。<strong>光纤耦合器</strong>又称分歧器，将光信号从一条光纤中分至多条光纤中。</p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network basis </tag>
            
            <tag> electric </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工业控制设备通信概览</title>
      <link href="/2018/05/10/review/rev-industrialcomm/"/>
      <url>/2018/05/10/review/rev-industrialcomm/</url>
      <content type="html"><![CDATA[<p>工业以太网、现场总线、工业无线是目前工业通信领域的三大主流技术。</p><a id="more"></a><p>IEC 61158于2007年第四版标准规定了20种类型的通信协议：<br><img src="/2018/05/10/review/rev-industrialcomm/IEC.JPG" alt="IEC">其中Type1可以理解为FF现场总线，Type2包括DeviceNet、ControlNet和EtherNet/IP，Type6由于应用不理想被撤销。</p><p>常见工业现场总线一览：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">推出时间</th><th style="text-align:center">主推公司</th><th>特点</th><th>链接</th></tr></thead><tbody><tr><td style="text-align:center">ASi (AS-Interface)</td><td style="text-align:center"></td><td style="text-align:center"></td><td>$1</td><td></td></tr><tr><td style="text-align:center">CAN</td><td style="text-align:center">1986</td><td style="text-align:center">博世</td><td></td><td></td></tr><tr><td style="text-align:center">CC-Link</td><td style="text-align:center">1996</td><td style="text-align:center">三菱</td><td></td><td><a href="/2018/05/16/knowledge/know-ccl/" title="CC-Link通信协议">CC-Link通信协议</a></td></tr><tr><td style="text-align:center">CompoNet</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">ControlNet</td><td style="text-align:center">1997</td><td style="text-align:center">罗克韦尔</td><td></td><td><a href="/2018/05/16/knowledge/know-cip/" title="CIP通信协议及其衍生">CIP通信协议及其衍生</a></td></tr><tr><td style="text-align:center">DeviceNet</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td><a href="/2018/05/16/knowledge/know-cip/" title="CIP通信协议及其衍生">CIP通信协议及其衍生</a></td></tr><tr><td style="text-align:center">Fipio</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">InterBus</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">LonWorks</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center"><strong>Modbus</strong></td><td style="text-align:center">1979</td><td style="text-align:center">施耐德</td><td></td><td><a href="/2018/05/03/knowledge/know-modbus/" title="Modbus通信协议">Modbus通信协议</a></td></tr><tr><td style="text-align:center"><strong>Profibus</strong></td><td style="text-align:center">1986</td><td style="text-align:center">西门子</td><td></td><td><a href="/2018/05/04/knowledge/know-profi/" title="Profibus和Profinet通信协议">Profibus和Profinet通信协议</a></td></tr></tbody></table></div><p>常见工业网络协议一览：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">推出时间</th><th style="text-align:center">主推公司</th><th>特点</th><th>链接</th></tr></thead><tbody><tr><td style="text-align:center">CC-Link IE</td><td style="text-align:center">xxxx</td><td style="text-align:center">三菱</td><td></td><td><a href="/2018/05/16/knowledge/know-ccl/" title="CC-Link通信协议">CC-Link通信协议</a></td></tr><tr><td style="text-align:center">EtherCAT</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">EtherNet/IP</td><td style="text-align:center">2000</td><td style="text-align:center"></td><td></td><td><a href="/2018/05/16/knowledge/know-cip/" title="CIP通信协议及其衍生">CIP通信协议及其衍生</a></td></tr><tr><td style="text-align:center"><strong>Modbus-TCP</strong></td><td style="text-align:center">1998</td><td style="text-align:center">施耐德</td><td></td><td><a href="/2018/05/03/knowledge/know-modbus/" title="Modbus通信协议">Modbus通信协议</a></td></tr><tr><td style="text-align:center"><strong>Profinet</strong></td><td style="text-align:center">2001</td><td style="text-align:center">西门子</td><td></td><td><a href="/2018/05/04/knowledge/know-profi/" title="Profibus和Profinet通信协议">Profibus和Profinet通信协议</a></td></tr><tr><td style="text-align:center">SERCOS Ⅲ</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table></div><p>其他通信协议：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">推出时间</th><th style="text-align:center">主推公司</th><th>特点</th><th>链接</th></tr></thead><tbody><tr><td style="text-align:center">BACnet</td><td style="text-align:center">wangluo</td><td style="text-align:center"></td><td></td><td>$1</td></tr><tr><td style="text-align:center">GD (Global Data)</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">Ethernet TCP/IP</td><td style="text-align:center">以太网</td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">IO-Link</td><td style="text-align:center">点对点</td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">USS</td><td style="text-align:center"></td><td style="text-align:center">西门子</td><td></td><td><a href="/2018/05/14/knowledge/know-uss/" title="USS通用串行接口协议">USS通用串行接口协议</a></td></tr><tr><td style="text-align:center">USB</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr></tbody></table></div>]]></content>
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protocol </tag>
            
            <tag> industrial network </tag>
            
            <tag> field bus </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《数据库原理与应用》笔记</title>
      <link href="/2018/05/10/note/note-database/"/>
      <url>/2018/05/10/note/note-database/</url>
      <content type="html"><![CDATA[<p>《数据库原理与应用——SQL Server 2016版本》 清华大学出版社<br><a id="more"></a></p><h2><span id="第七章-创建与管理数据库表">第七章 创建与管理数据库表</span></h2><h2><span id="第十章-存储过程与触发器">第十章 存储过程与触发器</span></h2><p><strong>存储过程</strong>是由一系列Transact-SQL语句构成的程序，经编译后存储在数据库中，可以通过名称直接调用。存储过程还可以接受参数，提高存储过程的灵活性。在SQL Server中，存储过程的类型主要有：用户存储过程、扩展存储过程和系统存储过程。<strong>用户存储过程</strong>包括Transact-SQL存储过程和CLR存储过程；<strong>扩展存储过程</strong>可以加载外部DLL；<strong>系统存储过程</strong>用来实现数据库的管理活动，存放在master中，但其他数据库也可以调用。常用系统存储过程和分类见书P301。</p><p>创建和修改存储过程的语法：</p><pre><code>{CREATE|ALTER} PROC[EDURE] 存储过程(组)名[;序号][{@参数名 数据类型} [=默认值] [OUTPUT]] [,... n][WITH {RECOMPILE|ENCRYPTION|RECOMPILE,ENCRYPTION}][FOR REPLICATION]AS {sql语句 [,... n]} </code></pre><p>删除存储过程的语法：</p><pre><code>DROP PROC[EDURE] 存储过程(组)名</code></pre><p>执行存储过程的语法：</p><pre><code>EXEC[UTE] 存储过程(组)名[;序号][[@参数名=]参数值|@参数名 [OUTPUT]|[DEFAULT]] [,... n][WITH RECOMPILE]</code></pre><p><strong>触发器</strong>是一种特殊的存储过程，可以看作是表定义的一部分，用于对表进行完整性约束。在SQL Server中，触发器的类型主要有：DML触发器、DDL触发器和登录触发器。</p><p>当数据库中发生数据操纵语言(DML)事件时将调用<strong>DML触发器</strong>。按照触发操作的不同可以分为INSERT触发器、UPDATE触发器和DELETE触发器，SQL Server为每个语句创建deleted表或（和）inserted表，表结构与定义触发器的表结构相同，触发器执行完成后自动删除。按照触发时间的不同可以分为AFTER(FOR)触发器和INSTEAD OF触发器。<br>当数据库中发生数据定义语言(DLL)事件时将调用<strong>DLL触发器</strong>，主要用于任务管理。DLL事件主要包括CREATE/ALTER/DROP/GRANT/DENY/REVOKE等语句操作。<br>LOGON事件激发<strong>登录触发器</strong>，将在登录身份验证阶段完成之后用户会话建立之前触发。</p><p>创建和修改DML触发器的语法：</p><pre><code>{CREATE|ALTER} TRIGGER [模式名.]触发器名ON {表名|视图名}[WITH DML触发器选项 [,... n]]{FOR|AFTER|INSTEAD OF}{[INSERT][,][UPDATE][,][DELETE]}AS {sql语句 [,... n]}</code></pre><p>删除DML触发器的语法：</p><pre><code>DROP TRIGGER 触发器名 [,... n]</code></pre><p>创建和修改DLL触发器发的语法：</p><pre><code>{CREATE|ALTER} TRIGGER 触发器名ON {DATABASE|ALL SERVER}[WITH DLL触发器选项 [,... n]]{FOR|AFTER} {触发事件名称|触发事件分组名称} [,... n]AS {sql语句 [,... n]}</code></pre><p>其中常见的数据库作用域的DLL语句和服务器作用域的DLL语句见P315。</p><p>删除DLL触发器的语法：</p><pre><code>DROP TRIGGER 触发器名 [,... n]ON {DATABASE|ALL SERVER}</code></pre><p>启用和禁用触发器的语法：</p><pre><code>{ENABLE|DISABLE} TRIGGER {[模式名.]触发器名 [,... n]|ALL}ON {表名|视图名|DATABASE|ALL SERVER}</code></pre>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> sql server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Profibus和Profinet通信协议</title>
      <link href="/2018/05/04/knowledge/know-profi/"/>
      <url>/2018/05/04/knowledge/know-profi/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/04/knowledge/know-profi/logo.jpg" alt="pi-logo"></p><p><strong>Profibus(Process Field Bus，过程现场总线)</strong>是一种国际化、开放式、不依赖于设备生产商的现场总线标准</p><p><strong>Profinet(Process Field Net, )</strong></p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protocol </tag>
            
            <tag> industrial network </tag>
            
            <tag> field bus </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Modbus通信协议</title>
      <link href="/2018/05/03/knowledge/know-modbus/"/>
      <url>/2018/05/03/knowledge/know-modbus/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/03/knowledge/know-modbus/th.jpg" alt="modbus-logo"></p><h3><span id="modbus历史">Modbus历史</span></h3><p><strong>Modbus协议</strong>最早由Modicon公司（现为施耐德电气公司的品牌）于1979年开发，旨在实现可编程控制器(PLC)之间的通信，后逐渐被大多数公司认可，成为事实上的标准协议，是<strong>全球第一个真正用于工业现场的总线协议</strong>。<br>该公司后来还推出增强型Modbusplus(MB+)协议，完整定义了通信协议、网络结构、线缆等，是典型的令牌环网，与Modbus差异较大。<br>2004年起施耐德电气已将Modbus协议的所有权移交并成立了<strong><a href="http://modbus.org/" target="_blank" rel="noopener">Modbus组织</a></strong>，为之后的发展奠定了基础。在中国，Modbus已经成为国家标准GB/T19582-2008。</p><h3><span id="modbus概述">Modbus概述</span></h3><p>Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型，协议本身没有定义物理层，只是定义了消息帧格式、描述了设备请求和返回数据的过程以及侦测错误的手段等。在现实使用中，可以通过网关将串行链路(RS232/RS485)和以太网等不同物理连接网络通过Modbus协议组成统一的系统。<br><img src="/2018/05/03/knowledge/know-modbus/tcp-structure.JPG" alt="modbus-unified"></p><p><strong>Modbus协议栈</strong>主要包括<a href="http://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf" target="_blank" rel="noopener">Modbus应用层协议</a>、<a href="http://modbus.org/docs/Modbus_over_serial_line_V1_02.pdf" target="_blank" rel="noopener">Modbus串行链路协议</a>和<a href="http://modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf" target="_blank" rel="noopener">Modbus在以太网上的映射</a>，相应的规范可点击链接下载。<br><img src="/2018/05/03/knowledge/know-modbus/stack2.JPG" alt="modbus-stack"></p><h3><span id="modbus应用层协议">Modbus应用层协议</span></h3><p>Modbus应用层协议(OSI L7)规定了与下层实现无关的<strong>协议数据单元</strong>(Protocol Data Unit, PDU)，Modbus协议在某种总线或网络上的映射定义了<strong>应用数据单元</strong>(Application Data Unit, ADU)。不论是Modbus串行链路协议、以太网协议还是其他由Modbus衍生的协议，协议数据单元PDU都由<strong>功能代码段</strong>和<strong>数据段</strong>组成，数据段可以不存在。<br><img src="/2018/05/03/knowledge/know-modbus/general-pdu.JPG" alt="modbus-pdu"></p><h4><span id="请求回应模型">请求——回应模型</span></h4><p>在上层协议中，发出请求的一方为客户端Client，响应的一方为服务端Server。<br>在客户端发出请求消息中，功能代码告知服务端要执行何种功能。数据段包含了服务端要执行功能的任何附加信息。<br>如果服务端产生正常的回应，则返回相同的功能代码给客户端，数据段包括了服务端收集的数据；如果有错误发生，服务端将功能代码的MSB置1返回给客户端，同时数据段包含了描述此错误信息的代码。</p><h4><span id="数据编码和类型">数据编码和类型</span></h4><p>采用<strong>高字节序</strong>(Big-Endian)，即高字节先发送、低字节后发送。<br>Modbus协议中只有两种数据类型，即位bit和字word(16-bit)，根据访问类型分为以下四种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">访问</th><th style="text-align:left">内容</th></tr></thead><tbody><tr><td style="text-align:center">离散量输入(Discrete Input)</td><td style="text-align:center">位bit</td><td style="text-align:center">只读</td><td style="text-align:left">IO系统提供这种类型数据</td></tr><tr><td style="text-align:center">线圈(Coil)</td><td style="text-align:center">位bit</td><td style="text-align:center">读写</td><td style="text-align:left">通过应用程序改变这种类型数据</td></tr><tr><td style="text-align:center">输入寄存器(Input Register)</td><td style="text-align:center">字word</td><td style="text-align:center">只读</td><td style="text-align:left">IO系统提供这种类型数据</td></tr><tr><td style="text-align:center">保持寄存器(Holding Register)</td><td style="text-align:center">字word</td><td style="text-align:center">读写</td><td style="text-align:left">通过应用程序改变这种类型数据</td></tr></tbody></table></div><p>地址寻址从0开始，详细的设备地址映射参见具体设备手册。</p><h4><span id="功能代码">功能代码</span></h4><p>功能代码段占用1个字节，取值范围为1-255，其中128-255为保留值，用于异常消息应答报文（原功能代码MSB置1）；1-127为功能代码编号，其中65-72和100-110为用户自定义功能代码，其余取值为通用功能代码。<strong>通用功能代码</strong>(Public Function Code)是已经公布的功能代码，由确定的功能，用户不能修改。<br>常用的通用功能代码如下：<br><img src="/2018/05/03/knowledge/know-modbus/pfc.JPG" alt="modbus-func-code">详细用法见<a href="http://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf" target="_blank" rel="noopener">Modbus应用层协议</a>。</p><h3><span id="modbus串行链路协议">Modbus串行链路协议</span></h3><p>Modbus针对串行链路的协议规定了通信的物理层和数据链路层(OSI L1/2)。物理层采用多种物理接口，最常用的是EIA/TIA-485双线接口。</p><h4><span id="主从模式">主从模式</span></h4><p>数据链路层采用<strong>主从通信模式(Master/Slave)</strong>，只有一个主设备可以初始化通信，并对总线上所有从设备进行控制。</p><ul><li>所有通信由主设备发出，从设备只能对主设备进行响应，互相不允许直接通信。</li><li>主设备对应上层协议中的客户端，从设备对应上层协议中的服务端。</li></ul><p>在<strong>单播模式</strong>(Unicast Mode)中，主设备发送请求至某个特定的从设备，从设备接到请求后进行应答并把消息反馈给主设备；在<strong>广播模式</strong>(Broadcast Mode)中，主设备可同时向多个从设备发送请求（设备地址0），从设备对广播请求不进行响应。<br>对于串行链路，应用数据单元ADU最大长度为256字节，协议数据单元PDU最大长度为253字节。<br>由于主站一次只能读取一个从站的数据，Modbus通信采用轮询方式，用在实时性要求较低的场合。</p><h4><span id="报文格式">报文格式</span></h4><p>串行链路的通用Modbus报文（消息帧）形式如下：<br><img src="/2018/05/03/knowledge/know-modbus/g1.JPG" alt="modbus-frame"><br><strong>1. Modbus-RTU</strong></p><ul><li>该模式中直接发送二进制数据流，以至少3.5个字符时间的停顿间隔分隔两帧，作为两帧开始和终止的标志，整个消息帧必须为连续的传输流，同一帧的两个数据间隔不能超过1.5个字符时间</li><li>在传输过程中需要定时器，从设备不断侦测总线及停顿间隔，当第一个域（即地址域）接收到，每个从设备都进行解码以判断是否发给自己</li><li>数据校验采用CRC（循环冗余校验），详见<a href="/2018/05/14/knowledge/know-crc/" title="CRC循环冗余校验码">CRC循环冗余校验码</a></li><li>地址域1个字节，功能代码1个字节，CRC校验2个字节，数据至多为252字节</li></ul><p><strong>2. Modbus-ASCII</strong></p><ul><li>该模式中消息的每个字节用16进制表示0x00-0xff，转化为两个ASCII字符进行发送，可以使用的传输字符是0-9、A-F，消息帧以字符”:”(ASCII码3A)作为起始符，以回车换行符(ASCII码0D,0A)作为终止符，同一帧的两个数据间隔可至多达到1s</li><li>在传输过程中不需要定时器，从设备不断侦测”:”字符，当接收到时每个设备都解码下个域（即地址域）来判断是否发给自己</li><li>数据校验采用LRC（纵向冗余校验），检测消息帧中除了开始符和终止符外的内容</li><li>起始符1个字节，地址域2个字节，功能代码2个字节，LRC校验2个字节，终止符2个字节，数据至多为2*252字节</li><li>该模式也称为命令行模式，由于发送的是可视化字符串，调试简便，但该模式传输效率较低</li></ul><h3><span id="modbus以太网协议">Modbus以太网协议</span></h3><p>基于Modbus协议进行以太网传输有多种形式，官方文档中给出的是基于Ethernet TCP/IP的Modbus TCP/IP（即Modbus-TCP），定义了TCP传输的报文格式以及默认端口号502。除此之外还有Modbus over TCP/IP（将Modbus-RTU/ASCII报文作为TCP数据包）、Modbus UDP/IP、Modbus over UDP/IP等非标准变体。</p><h4><span id="modbus-tcp报文格式">Modbus-TCP报文格式</span></h4><p>Modbus-TCP报文（消息帧）形式如下：<br><img src="/2018/05/03/knowledge/know-modbus/g3.JPG" alt="modbus-frame">数据以类似Modbus-RTU的二进制数据流发送。由于Ethernet TCP/IP数据链路层的校验机制保证了数据的完整性，报文中不含有数据校验，也没有地址域。同时Modbus-TCP加入了4个域、7个字节的报文头来识别应用数据单元ADU，称为<strong>MBAP报文头</strong>(Modbus Application Protoco Header)，具体形式如下：<br><img src="/2018/05/03/knowledge/know-modbus/MBAP_header.JPG" alt="modbus-tcp-header"></p><ol><li>事务处理标识符：用于事务处理配对，在响应中服务端复制请求的事务处理标识符</li><li>协议标识符：用于系统内多路复用，通过值0识别Modbus协议</li><li>长度：单元标识符和PDU的长度</li><li>单元标识符：用于以太网和串行链路间的网关对串行链路从站的通信</li></ol><h4><span id="modbus-rtps">Modbus-RTPS</span></h4><p>To be continued…</p><p>More <a href="http://www.modbustools.com/" target="_blank" rel="noopener">Modbus库和仿真软件</a></p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protocol </tag>
            
            <tag> industrial network </tag>
            
            <tag> field bus </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DNS域名系统与localhost</title>
      <link href="/2018/05/03/knowledge/know-DNS&amp;localhost/"/>
      <url>/2018/05/03/knowledge/know-DNS&amp;localhost/</url>
      <content type="html"><![CDATA[<p><strong>DNS(Domain Name System，域名系统)</strong>在万维网上作为域名和IP地址相互映射的分布式数据库。通过域名得到对应IP地址的过程叫做<strong>域名解析</strong>。DNS协议运行在UDP协议之上，使用UDP端口号53。为保证服务的高可用性，DNS要求使用多台名称服务器冗余支持每个区域。</p><p>Reference <a href="https://baike.baidu.com/item/DNS/427444#reference-[4]-15346050-wrap" target="_blank" rel="noopener">百度百科</a></p><p><strong>localhost</strong>是一个域名，在windows中该域名是由/etc/hosts文件预定义的，默认对于ipv4指向127.0.0.1，对于ipv6指向::1，可对hosts文件进行修改配置为任意的IP地址，但可能导致只认127.0.0.1的软件失效。</p><p>127.0.0.1/8整个都是环回(loopback)地址，用来测试本机的TCP/IP协议栈，以及本机中各个应用之间的网络交互，也称虚拟网卡。Windows中看不到这个接口，Linux中这个接口叫lo，可通过ifconfig查看。</p><p>本机IP地址一般指绑定在物理或虚拟接口上的IP地址，供其他设备访问。</p><p>Reference <a href="https://www.zhihu.com/question/23940717" target="_blank" rel="noopener">知乎</a></p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network basis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NTP网络时间协议</title>
      <link href="/2018/04/28/knowledge/know-NTP/"/>
      <url>/2018/04/28/knowledge/know-NTP/</url>
      <content type="html"><![CDATA[<p><strong>NTP(Network Time Protocol，网络时间协议)</strong>是用来同步网络中各个计算机时间的协议，属于应用层协议，采用UDP报文传输，使用UDP端口号为123。连接到互联网上的主机通过NTP与UTC(Universal Time Coordinate，世界协调时)同步，UTC由原子钟报时。<br>计算机主机一般同多个时钟服务器连接，利用统计学的算法过滤来自不同服务器的时间，选择最佳的路径和来源以便校正主机时间。</p><p>Reference <a href="https://baike.baidu.com/item/nTP" target="_blank" rel="noopener">百度百科</a><br>More <a href="http://blog.163.com/yzc_5001/blog/static/2061963420121283050787/" target="_blank" rel="noopener">sms的博客</a></p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network basis </tag>
            
            <tag> protocol </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>修改虚拟机启动时间</title>
      <link href="/2018/04/28/tip/tip-vm-time/"/>
      <url>/2018/04/28/tip/tip-vm-time/</url>
      <content type="html"><![CDATA[<p>由于软件license的时间限制，需要用过去的时间启动虚拟机。</p><ol><li>修改主机时间。启动虚拟机后系统时间即当前主机时间。但在主机中打开Chrome浏览器会报错，提示时钟慢了，无法建立私密连接。</li><li>修改虚拟机启动时间。用文本编辑器打开虚拟机.vmx文件，寻找以下设置项并关闭同步，设置虚拟机启动时间，保存后启动虚拟机。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tools.syncTime = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.continue = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.restore = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.resume.disk = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.shrink = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.tools.startup = &quot;FALSE&quot; </span><br><span class="line">rtc.startTime = 1462003200</span><br></pre></td></tr></table></figure></li></ol><p>注：rtc.startTime是从1970年1月1日0时0分0秒（Unix时间）到系统启动时间间隔的时间，单位是秒，可以到<a href="http://www.onlineconversion.com/unix_time.htm" target="_blank" rel="noopener">计算时间的网站</a>上换算得到希望虚拟机的启动时间。</p><p>Reference <a href="https://blog.csdn.net/sagafive/article/details/53031740" target="_blank" rel="noopener">SagaFive的专栏</a></p>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual machine </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用C#编写OPC程序</title>
      <link href="/2018/04/28/experience/exp-cs-opc/"/>
      <url>/2018/04/28/experience/exp-cs-opc/</url>
      <content type="html"><![CDATA[<p><a href="https://opcfoundation.org/" target="_blank" rel="noopener">OPC基金会官网</a>真是弱爆了。</p><h3><span id="1-配置opcdaautodll">1. 配置OPCDAAuto.dll</span></h3><p>OPC的自动化接口即OPCDAAuto.dll<br>1)下载文件OPCDAAuto.dll，版本2.2.5.30<br>2)放到System32文件夹下，用管理员身份打开cmd<br>3)输入regsvr32 opcdaauto.dll后提示成功<br>4)打开Visual Studio在项目中打开相应项目，对解决方案右键-添加-引用，浏览选择opcdaaturo.dll<br>5)依赖项中出现COM-Interop.OPCAutomation，在C#程序开头using OPCAutomation；不再显示红色波浪线错误，即配置成功。</p><p>Reference <a href="https://blog.csdn.net/u012252959/article/details/49699559" target="_blank" rel="noopener">u012252959的博客</a></p>]]></content>
      
      <categories>
          
          <category> experience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OPC </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Learning hard C#学习笔记》笔记</title>
      <link href="/2018/04/28/note/note-cs/"/>
      <url>/2018/04/28/note/note-cs/</url>
      <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#第一章-基础知识">第一章 基础知识</a></li><li><a href="#第八章-委托">第八章 委托</a></li><li><a href="#第九章-事件">第九章 事件</a></li></ul><!-- tocstop --><p>《Learning hard C#学习笔记》 李志 人民邮电出版社<br><a id="more"></a></p><h2><span id="第一章-基础知识">第一章 基础知识</span></h2><p>C#</p><h2><span id="第八章-委托">第八章 委托</span></h2><p><strong>委托</strong>是C#中最中需要的特性之一，它使得C#中的函数可以作为参数被传递，与C/C++中的函数指针类似。它是一个特殊的类，所有的委托都是从System.MulticastDelegate类派生的。<br>委托的定义和方法的定义类似，只是在定义前多了一个delegate关键字：</p><pre><code>访问修饰符 delegate 返回类型 委托名([参数表])</code></pre><p>能被委托包装的方法需要满足：</p><ol><li>方法的签名与委托一致（参数个数、类型、顺序）</li><li>方法的返回类型与委托一致</li></ol><p>委托也可以封装多个方法，称为<strong>委托链</strong>或多路广播委托，在委托链上的委托都会被顺序执行。可以通过“+”运算符把委托链接到一个委托对象实例上，也可以使用“-”运算符将某个委托从委托链对象上移除。</p><div><div class="fold_hider"><div class="close hider_title">委托和委托链的例子（点击显示代码）</div></div><div class="fold"><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSbook</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//委托的定义</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params">MyDelegate mydelegate</span>)</span>&#123;</span><br><span class="line">            mydelegate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            MyDelegate m = <span class="keyword">new</span> MyDelegate(Program.Mult);</span><br><span class="line">            <span class="comment">// 方法Program.Mult作为方法MyMethod的参数</span></span><br><span class="line">            MyMethod(m);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            MyDelegate p = <span class="keyword">new</span> MyDelegate(<span class="keyword">new</span> Program().Add);</span><br><span class="line">            MyDelegate q = <span class="keyword">new</span> MyDelegate(<span class="keyword">new</span> Program().Sub);</span><br><span class="line">            MyDelegate chain = <span class="literal">null</span>;</span><br><span class="line">            chain += m;</span><br><span class="line">            chain += p;</span><br><span class="line">            chain += q;</span><br><span class="line">            chain -= m;</span><br><span class="line">            chain(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实例方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = para1 + para2;</span><br><span class="line">            Console.WriteLine(<span class="string">"Sum is: "</span> + sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Sub</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sub = para1 - para2;</span><br><span class="line">            Console.WriteLine(<span class="string">"Sub is: "</span> + sub);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mult</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mul = para1 * para2;</span><br><span class="line">            Console.WriteLine(<span class="string">"Mul is: "</span> + mul);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2><span id="第九章-事件">第九章 事件</span></h2>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> programming language </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FactoryTalk Transaction Manager使用心得</title>
      <link href="/2018/04/27/experience/exp-trans-1/"/>
      <url>/2018/04/27/experience/exp-trans-1/</url>
      <content type="html"><![CDATA[<h2><span id="基本概念">基本概念</span></h2><p><strong>FactoryTalk Transaction Manager</strong>（前身是RSSql）是Rockwell公司FactoryTalk系列组态软件之一，主要实现工控系统与数据库的通信，该系列软件基于<a href="https://baike.baidu.com/item/SOA/2140650" target="_blank" rel="noopener">SOA架构</a>开发，因此Transaction Manager应用软件部分实际上是对各个数据传送服务进行配置的UI界面，该软件的核心实际上是各个接口的服务程序。<br><a id="more"></a></p><p><img src="/2018/04/27/experience/exp-trans-1/structure.png" alt="structure"></p><p>Transaction and Control Manager服务包含了Transaction Manager Service服务和FactoryTalk Live Data控制接口，可以通过该服务连接Rockwell软件和所有OPC服务器。</p><p>启动操作系统后查看服务列表，可以看到Transaction Manager相关的各个服务。</p><p><img src="/2018/04/27/experience/exp-trans-1/services.png" alt="services"></p><p>FactoryTalk Transaction Manager可以使用以下<strong>控制接口</strong>(control connector)，来关联数据点(data point)或存储地址(memory location)：</p><ol><li>FactoryTalk Live Data</li><li>Dynamic Data Exchange (DDE)</li><li>RSLinx Classic OPC</li><li>RSView32</li><li>Generic OPC</li></ol><p>FactoryTalk Transaction Manager可以使用以下<strong>企业接口</strong>(enterprise connector)，来创建数据对象(data object)与企业系统中的数据表(database table)和预存过程(stored procedure)进行交互：</p><ol><li>Open Database Connectivity (ODBC)</li><li>Microsoft OLE DB</li><li>Microsoft COM+</li><li>Oracle Call Interface (OCI)</li><li>Time-series Data Compression</li><li>FactoryTalk Metrics connector</li></ol><h2><span id="1-opc-server-gt-sql-server">1. OPC Server -&gt; SQL Server</span></h2><p>OPC Server: KEPSever Enterprise 5.13<br>SQL Server: Microsoft SQL Server 2008 R2</p><h2><span id="2-live-data-gt-sql-server">2. Live Data -&gt; SQL Server</span></h2><h2><span id="3-sql-server-gt-live-data">3. SQL Server -&gt; Live Data</span></h2>]]></content>
      
      <categories>
          
          <category> experience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OPC </tag>
            
            <tag> FactoryTalk </tag>
            
            <tag> Rockwell </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《OPC应用程序入门》笔记</title>
      <link href="/2018/04/27/note/note-opc/"/>
      <url>/2018/04/27/note/note-opc/</url>
      <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#第一章-opc基础知识">第一章 OPC基础知识</a><ul><li><a href="#11-什么是opc">1.1 什么是OPC</a></li></ul></li></ul><!-- tocstop --><p>《OPC应用程序入门》<br><a id="more"></a></p><p><img src="/2018/04/27/note/note-opc/ch1-1.PNG" alt="ch1-1"></p><h2><span id="第一章-opc基础知识">第一章 OPC基础知识</span></h2><h3><span id="11-什么是opc">1.1 什么是OPC</span></h3><p>OPC(OLE for Process Control)是为不同供应商设备和应用程序之间的软件接口标准化而提出的，使其间的数据交换不依赖于特定开发语言和开发环境。它利用Windows中的OLE/COM技术实现工业制造系统过程控制中数据交换的标准化。OPC系统由提供数据收集服务的OPC服务器(OPC Server)、接受数据服务的OPC应用程序(OPC Client)和OPC接口所构成。</p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OPC </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
