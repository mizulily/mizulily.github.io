<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>TTL字段</title>
      <link href="/2019/04/17/knowledge/know-ttl/"/>
      <url>/2019/04/17/knowledge/know-ttl/</url>
      <content type="html"><![CDATA[<p>TTL全称是<strong>生存时间</strong>(Time-to-Live)，在IP和ICMP协议中均包含该字段。<br>当我们对网络上的主机进行ping操作的时候，我们本地机器会发出一个数据包，数据包经过一定数量的路由器传送到目的主机，但是由于很多的原因，一些数据包不能正常传送到目的主机，那如果不给这些数据包一个生存时间的话，这些数据包会一直在网络上传送，导致网络开销的增大。当数据包传送到一个路由器之后，TTL就自动减1，如果减到0了还是没有传送到目的主机，那么就自动丢失。<br>最新的Windows系统初始值为TTL=128，Linux系统初始值为TTL=64/255。在进行ping操作时，返回的TTL是经过路由递减后的TTL，因此若ping返回的TTL=51，那么可以推测到目的主机经过了64-51=13个路由，且目的主机可能为Linux系统。<br>可以使用tracert命令查看到达目标主机经过的所有路由节点，通常超过30个节点还没有完成跟踪的网站被认为是无法访问的。</p>]]></content>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows三个内置账户</title>
      <link href="/2019/04/17/knowledge/know-win-builtin/"/>
      <url>/2019/04/17/knowledge/know-win-builtin/</url>
      <content type="html"><![CDATA[<p>Windows中处于安全性考虑有三个由操作系统创建的、较为特别的内置账户或组，主要作为系统服务或进程运行账户，与通常的用户账户没有任何关联，分别为Local System、Network Service和Local Service。</p><ol><li><p>Local System账户，全名为NT AUTHORITY\SYSTEM，预设拥有本机所有权限，当它访问网络资源时是作为计算机的域账户使用的。</p></li><li><p>Network Service账户，全名为NT AUTHORITY\NETWORK SERVICE，预设拥有本机部分权限，它能以计算机的名义访问网络资源，并根据实际环境把访问凭据提交给远程计算机。</p></li><li><p>Local Service账户，全名为NT AUTHORITY\LOCAL SERVICE，预设拥有本机最小权限，并在网络凭证中具有匿名身份</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> system management </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发编程</title>
      <link href="/2019/04/01/knowledge/know-concurrent/"/>
      <url>/2019/04/01/knowledge/know-concurrent/</url>
      <content type="html"><![CDATA[<h2><span id="并发编程的三个模型">并发编程的三个模型</span></h2><ol><li><p>IO多路复用(Multiplexing)<br>也称为事件驱动模型，在单一进（线）程上下文中处理多个IO数据流，每个逻辑流都能访问该进（线）程的全部地址空间，适合处理很多闲置的IO。</p></li><li><p>多进程<br>每个逻辑控制流都是一个进程，由内核来调度和维护，每个进程由独立的虚拟地址空间，想要和其他进程通信，必须使用某种显式的进程间通信机制(Interprocess communication, IPC)。</p></li><li><p>多线程<br>线程运行在单一进程中，所有运行在同一个进程中的线程共享整个虚拟地址空间，包括代码、数据、堆栈等。线程间逻辑控制方式简单，但受限于2GB地址空间，线程之间的同步和加锁比较麻烦，一个线程的崩溃可能影响到整个程序的稳定性。</p></li><li><p>协程？</p></li></ol><h2><span id="进程间通信方式">进程间通信方式</span></h2><ol><li><p>管道(Pipe)</p></li><li><p>系统IPC<br>包括消息队列、信号、共享存储等。</p></li><li><p>套接字(Socket)</p></li></ol><h2><span id="线程间通信方式">线程间通信方式</span></h2>]]></content>
      
      
        <tags>
            
            <tag> programming </tag>
            
            <tag> concurrent </tag>
            
            <tag> process </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WLAN关闭随机物理地址</title>
      <link href="/2019/03/28/tip/tip-rand-mac/"/>
      <url>/2019/03/28/tip/tip-rand-mac/</url>
      <content type="html"><![CDATA[<p>在Win 10中打开“网络和Internet”，在左侧选择“WLAN”，点击“硬件属性”，可以查看WLAN网卡的物理地址(MAC)。<br>发现WLAN无线网卡的物理地址会根据所连接的网络发生变化。<br>实际上这是由于系统打开了对于WLAN的<strong>随机硬件地址</strong>功能，该功能使他人不能轻易获取本机的MAC地址来跟踪位置，如果需要固定的MAC地址进行绑定时要将该功能关闭。<br>当没有无线网络连接时，下方“随机硬件地址”栏点击关闭，此时MAC地址将固定不变。<br>当连接到某个无线网络时，点击网络名称，进入此网络的设置，同样在“随机硬件地址”栏下选择关闭，随后断开并重新连接该无线网络，此时MAC地址将固定不变。<br>由于后一项设置针对当前网络连接，因此从安全方面考虑仅在常用的无线网络中关闭该项设置即可。</p>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> WLAN </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件开发术语汇总</title>
      <link href="/2019/03/12/review/rev-softwaredev/"/>
      <url>/2019/03/12/review/rev-softwaredev/</url>
      <content type="html"><![CDATA[<p><strong>架构</strong> 就是指人们根据自己对世界的认识，为解决某个问题，主动地、有目的地去识别问题，并进行分解、合并，解决这个问题的实践活动。<br>软件架构，就是将客户的不同需求抽象成为抽象组件，并且能够描述这些抽象组件之间的通信和调用。它不仅涉及到结构与行为，而且还涉及到系统的使用，功能，性能，适应性，重用性，可理解性，经济性和技术约束的权衡和美学考虑。</p><p><strong>框架</strong>是一个提供了诸多服务，供开发人员进行二次开发，实现具体功能的应用系统，是可被应用开发者定制的应用骨架。<br>框架不是架构，框架比架构更具体，更偏重于技术，而架构偏重于设计。一个架构可以通过多种框架来实现。</p><p><strong>模式</strong>是指从生产经验和生活经验中经过抽象和升华提炼出来的核心知识体系。模式（Pattern）其实就是解决某一类问题的方法论。软件设计模式强调的是一个设计问题的解决方法，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>一个架构中可能会出现多个设计模式来解决多个问题。</p><p><strong>模块</strong>是一个通用概念，可能从功能或其他目的来区分。程序模块，是指的一段能够实现某个有价值目标的的成员代码段。功能模块的说法一般在分析和设计阶段出现得比较频繁，一个功能模块来表示一组功能的集合。模块的定义原则应该是：<strong>高内聚</strong>和<strong>低耦合</strong></p><p><strong>组件</strong>是面向对象里面的一个重用的概念，也称为<strong>构件</strong>，是一个具象的概念，是封装了一个或多个程序模块的实体。组件强调的是封装，利用接口进行交互。因为封装有不同层次的封装，对应不同层次的接口，在谈论组件的时候一定要分辨清楚谈论的层次和范围。</p><p><strong>插件</strong>是满足一定接口规范的具有一定功能的程序模块，通过和应用程序的互动，来替应用程序增加一些特定的功能。开发者可以在自己软件系统中设计相应的接口以匹配某个插件，也可以设计一定的接口规范，来让别人开发插件。<br>插件是是组件的一个子类，就是将组件中具有某些特点的组件归为插件，这些特点是：益于与系统分离，接口明晰，可以替换的程序模块。</p><p><strong>控件</strong>可视化的组件。</p><p><strong>中间件</strong>提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。</p><p>Reference<br><a href="https://www.cnblogs.com/doit8791/p/6129963.html" target="_blank" rel="noopener">软件架构、框架、模式、模块、组件、插件概念汇总</a></p>]]></content>
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software development </tag>
            
            <tag> term </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>加密算法和数字证书</title>
      <link href="/2019/03/06/knowledge/know-encryption/"/>
      <url>/2019/03/06/knowledge/know-encryption/</url>
      <content type="html"><![CDATA[<p><strong>对称加密</strong>是指加密与解密使用同样的密钥，安全性取决于密钥长度。密钥大小要考虑安全性和效率的权衡，一般小于256bit。对称加密的一大缺点是密钥的管理和分配， 将密钥发送到请求方的过程中有很大风险会被拦截。常用的对称加密算法有DES和AES。</p><p><strong>非对称加密</strong>使用了一对密钥，公钥发送给任何请求它的人，私钥由自己保管。与对称加密相比，非对称加密安全性大大提高，但是效率很低。常用的非对称加密算法是RSA。<br><strong>公钥</strong>与<strong>私钥</strong>成对出现，公钥用来加密和验章，私钥用来解密和签章，用公钥加密的内容只能用私钥解密，用私钥加密的内容只能用公钥解密。<br>当用户接受文件时，对方用该用户的公钥加密，该用户用自己的私钥解密，保证该信息只能由他看到，即安全传输。<br>当用户发送文件时，用自己的私钥签名，对方用该用户的公钥解密，保证信息是由该用户发出的，即<strong>数字签名</strong>。签名加密的内容与文件内容有关时，可以验证文件内容在发送过程中未被修改。</p><p>为了弥补对称加密的安全性问题和非对称加密的效率问题，通常采用两者结合的方式，将对称加密的密钥通过非对称加密发送出去。<br><img src="/2019/03/06/knowledge/know-encryption/DES+RSA.jpg" alt="encryption"></p><p>CA(Certificate Authority)即证书授权中心，是负责管理和签发证书的第三方机构，一般来说CA具有足够的权威性，是所有行业和公众认可的。证书授权中心将申请者的公钥、申请者和颁发者信息以及自己的签名一起用自己的私钥加密，生成<strong>数字证书</strong>。发送方只需将数字证书附上，接收方使用CA的公钥解密数字证书，得到发送方的真实公钥，避免公钥和数字签名被篡改。<br>颁发者和使用者相同的证书为<strong>自签名证书</strong>。<strong>根证书</strong>是CA给自己颁发的证书，是信任链的起始点，安装CA根证书意味着对这个CA的信任。</p><p>证书的编码格式通常有PEM（base64编码）和DER（二进制编码）。</p><ul><li>.crt .cer 证书文件</li><li>.key 私钥文件</li><li>.csr 证书签名请求</li><li>.pfx .keystore 包含证书和私钥（需要密码）</li></ul><p>在Windows中可以通过在命令提示符中输入certmgr打开证书管理工具。</p><p>Reference<br><a href="https://zhuanlan.zhihu.com/p/31477508" target="_blank" rel="noopener">知乎专栏——公钥和私钥</a><br><a href="https://songlee24.github.io/2015/05/03/public-key-and-private-key/" target="_blank" rel="noopener">理解公钥和私钥</a></p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encryption </tag>
            
            <tag> certification </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开源软件协议</title>
      <link href="/2019/02/28/knowledge/know-opensource/"/>
      <url>/2019/02/28/knowledge/know-opensource/</url>
      <content type="html"><![CDATA[<p>现今存在的开源软件协议很多，而经过Open Source Initiative 组织通过批准的开源协议目前有60多种（<a href="http://www.opensource.org/licenses/alphabetical" target="_blank" rel="noopener">http://www.opensource.org/licenses/alphabetical</a> ）。</p><p>要分清楚不同的开源协议，需要了解以下基本概念。<br><strong>贡献者</strong>指对开源项目提供了代码的人或实体，按照贡献的先后又可分为创始人和参与者；<strong>获取者</strong>是指开源项目的使用者。<br><strong>源代码</strong>是指由各种语言写成的未经编译的程序文本；<strong>目标代码</strong>是指经过编译后生成类似“类库”的程序，提供各种接口给他人使用的代码，如dll, jar等。<br><strong>衍生模块</strong>是指依托或包含开源代码而产生的代码；<strong>独立模块</strong>是指参考或借助开源代码开发出来的独立的、不包含或依赖源代码的功能模块。</p><p><img src="/2019/02/28/knowledge/know-opensource/opensource.png" alt="licenses"></p><p>在OSI网站上被列为主流及被广泛使用的许可有：</p><ol><li><p>Apache License, 2.0 (<strong>Apache</strong>-2.0)<br>允许使用者以其他协议形式修改和重新发布代码，允许闭源商业发布和销售，同时鼓励代码共享和尊重原作者著作权。</p></li><li><p>Berkerly Software Distribution (<strong>BSD</strong> 3-Clause, BSD 2-Clause)<br>允许使用者以其他协议形式修改和重新发布代码，允许闭源商业发布和销售，同时鼓励代码共享和尊重原作者著作权。</p></li><li><p>General Public Licese (<strong>GPL</strong>)<br>源代码和目标代码免费使用，但修改或衍生的代码不允许作为闭源的商业软件发布和销售，同时修改或衍生的代码必须采用同样的GPL许可证。</p></li><li><p>Lesser General Public Licese (<strong>LGPL</strong>)<br>允许商业软件通过目标代码引用的方式使用LGPL类库而不需要开源，但是修改或新增的额外代码必须采用LGPL协议，因此适合作为第三方类库引用，而不适合做二次开发。</p></li><li><p>MIT license (<strong>MIT</strong>)<br>允许修改、使用甚至出售MIT协议的代码，但是必须在发行版里包含原许可协议的声明。</p></li><li><p>Mozilla Public License 2 (<strong>MPL</strong>v2)<br>允许免费重发布、修改和使用，但要求修改后的代码版权归软件的发起者，围绕该软件的所有代码版权都集中在发起者手中。</p></li><li><p>Common Development and Distribution License (<strong>CDDL</strong>-1.0)<br>MPL的扩展协议，允许公共版权使用，无专利费并提供专利保护，可集成于商业软件中，允许自行发布许可。</p></li><li><p>Eclipse Public License (<strong>EPL</strong>-1.0)<br>允许任意使用、分发、修改及修改后闭源二次商业发布，但必须声明商业发布的源代码或目标代码的原始版本时可以获取的，并告知获取方法。</p></li></ol>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> open source </tag>
            
            <tag> license </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>职业技能培训</title>
      <link href="/2019/02/28/training/train-career/"/>
      <url>/2019/02/28/training/train-career/</url>
      <content type="html"><![CDATA[<h2><span id="社交行为风格">社交行为风格</span></h2>]]></content>
      
      <categories>
          
          <category> training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> career </tag>
            
            <tag> skill </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows中工作组、域及账户</title>
      <link href="/2018/12/26/knowledge/know-wkgp-dm-acc/"/>
      <url>/2018/12/26/knowledge/know-wkgp-dm-acc/</url>
      <content type="html"><![CDATA[<p>局域网上的资源需要管理，<strong>工作组</strong>和<strong>域</strong>是两种不同的资源管理模式。</p><ol><li><p>工作组<br>工作组(Workgroup)是松散的管理方式，每台计算机管理员只能管理本地计算机，没有统一查找网络资源的机制，也没有统一的用户账户身份验证机制，用户（本地或远程）登录该计算机只能使用本机的用户账户来验证身份，是较小规模计算机网络的组织形式。计算机安装操作系统后，默认属于WORKGROUP工作组。</p></li><li><p>域<br>域(Domain)是相对严格的组织，至少有一台服务器负责每台连入局域网的电脑和用户的验证工作，称为<strong>域控制器</strong>。域控制器中包含了这个域的账户、密码、计算机信息等构成的数据库，仅当局域网计算机的域、账号、密码都正确时可以访问域中的资源，否则以对等网用户的方式访问共享资源。</p></li></ol>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> system management </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单方ping不通的防火墙设置</title>
      <link href="/2018/12/19/tip/tip-ping-icmp/"/>
      <url>/2018/12/19/tip/tip-ping-icmp/</url>
      <content type="html"><![CDATA[<p>A与B在同一子网内，B可以ping通A，但A却ping不通B。关闭B防火墙后可以ping通。</p><p>原因：ICMP被B的防火墙禁止了<br>解决办法：防火墙-&gt;高级设置-&gt;入站规则，开启“文件与打印机共享（回显请求-ICMPv4-In）”</p>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ping </tag>
            
            <tag> firewall </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Oracle精髓》笔记</title>
      <link href="/2018/12/12/note/note-oracle/"/>
      <url>/2018/12/12/note/note-oracle/</url>
      <content type="html"><![CDATA[<!-- toc --><!-- tocstop --><p>《Oracle精髓》第五版 O’Reilly系列 机械工业出版社</p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解除虚拟机占用</title>
      <link href="/2018/12/10/tip/tip-vm-using/"/>
      <url>/2018/12/10/tip/tip-vm-using/</url>
      <content type="html"><![CDATA[<p>打开虚拟机时提示“该虚拟机似乎正在使用中。如果该虚拟机未在使用，请按‘获取所有权(T)’按钮获取它的所有权。否则，请按‘取消(C)’按钮以防损坏”。</p><p>这是由于虚拟机未正常关闭引起的，打开存放该虚拟机的目录，删除.lck文件夹即可。</p>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual machine </tag>
            
            <tag> VMWare </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《趣学CCNA》笔记</title>
      <link href="/2018/10/30/note/note-ccna/"/>
      <url>/2018/10/30/note/note-ccna/</url>
      <content type="html"><![CDATA[<a id="more"></a><!-- toc --><ul><li><a href="#522-ip地址分类">5.2.2 IP地址分类</a></li></ul><!-- tocstop --><h3><span id="522-ip地址分类">5.2.2 IP地址分类</span></h3><p>IPv4定义了5种地址类型，分别为A至E类。</p><p><strong>A类地址</strong>是最高位为0的地址，换算成十进制就是0.x.x.x~127.x.x.x之间的地址都属于A类地址，A类地址的前8位二进制数（第一段）是网络位。<br><strong>B类地址</strong>是最高两位为10的地址，换算成十进制就是128.x.x.x~191.x.x.x都属于B类地址，B类地址的前16位二进制数（第一、第二段）是网络位。<br><strong>C类地址</strong>是最高三位为110的地址，换算成十进制就是192.x.x.x~223.x.x.x都属于C类地址，C类地址的前24位二进制数（第一、第二、第三段）是网络位。<br><strong>D类地址</strong>是最高四位为1110的地址，换算成十进制就是224.x.x.x~239.x.x.x都属于D类地址，也就是<strong>组播地址</strong>。</p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>将Ghost系统还原到虚拟机</title>
      <link href="/2018/10/19/tip/tip-vm-ghost/"/>
      <url>/2018/10/19/tip/tip-vm-ghost/</url>
      <content type="html"><![CDATA[<ol><li><p>创建空虚拟机<br>安装来源界面，选择“稍后安装操作系统”，并选择需要还原的系统和版本，选择合适的内存、硬盘后完成创建。</p></li><li><p>用老毛桃进入WinPE<br>打开老毛桃，左侧选择ISO模式，点击“生成ISO”会在D盘创建名为“老毛桃ISO”的文件夹。在刚创建的虚拟机设置里面，“硬件”标签中的光驱选择“使用ISO映像文件”并选择“老毛桃ISO”文件夹下的LMT.iso文件，“选项”标签中的高级，固件类型选择“BIOS”。<br>启动虚拟机后引导进入WinPE，选择一项进入，建议选择新机器的WinPE，启动成功后会进入老毛桃的WinPE，包含多个系统维护工具。</p></li><li><p>用老毛桃还原Ghost<br>首先进行硬盘分区，打开DiskGenius分区工具，点击快速分区，选择MBR或者GUID分区表类型，并完成分区。<br>点击“老毛桃PE装机工具”，选择“还原分区”，选择需要还原的Ghost文件和安装的分区，点击确定进行还原。</p></li><li><p>用老毛桃修复引导记录<br>还原完成后重启出现了“The boot configuration data for your pc is missing or contain errors”报错，点击启动“修复引导工具”并选择还原后的系统分区。<br>注意，若选用GUID分区，需要创建ESP分区并将引导放入ESP分区，并在虚拟机中设置UEFI启动。<br>修复完成后重启就可以正常启动啦！</p></li></ol>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual machine </tag>
            
            <tag> VMWare </tag>
            
            <tag> ghost </tag>
            
            <tag> LAOMAOTAO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>查询SQL Server表的索引</title>
      <link href="/2018/10/08/tip/tip-sqlindex/"/>
      <url>/2018/10/08/tip/tip-sqlindex/</url>
      <content type="html"><![CDATA[<p>1.执行存储过程</p><pre><code>EXEC sp_helpindex 表名</code></pre><p>2.或者获取表的所有信息，即执行存储过程</p><pre><code>EXEC sp_help 表名</code></pre><p>在输出结果中包含’index_name’和’index_keys’项</p><p>3.将表的设计模式打开，查看表属性</p>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL Server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>结构化数据、半结构化数据和非结构化数据</title>
      <link href="/2018/09/28/knowledge/know-datastruct/"/>
      <url>/2018/09/28/knowledge/know-datastruct/</url>
      <content type="html"><![CDATA[<p><strong>结构化数据</strong>是指可以使用关系型数据库表示和存储，表现为二维形式的数据。一般特点是数据以行为单位，一行数据表示一个实体信息，一列数据具有相同的类型。结构化数据的存储和排列是很有规律的，有利于查询和修改，但扩展性不好。</p><p><strong>半结构化数据</strong>不顾和关系型数据库的数据模型结构，但包含相关标记，用来分隔语义元素并对记录和字段分层，也称自描述的结构。半结构化数据，对于同一类实体可以有不同的属性，个数也不一定相同，属性的顺序不重要，可以看作树或者图的存储结构，常见的有xml和json文件，扩展性较好。</p><p><strong>非结构化数据</strong>就是没有固定结构的数据，如文档、图片、视频等，对于这类数据一般直接整体进行存储，且通常存储为二进制数据格式。</p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data management </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>离散制造与流程制造</title>
      <link href="/2018/09/25/knowledge/know-manufacture/"/>
      <url>/2018/09/25/knowledge/know-manufacture/</url>
      <content type="html"><![CDATA[<p>根据生产中使用的物质形态，制造业可划分为离散制造和流程制造。</p><p><strong>离散制造</strong>是将不同的零部件加工、装配成最终产品，如汽车、电子、船舶等制造业。<br>离散制造主要特征为生产过程中没有发生物质改变，只是物料的形状和组合发生改变，一般具有相对固定的产品结构、原材料清单和零部件配套关系。<br>离散制造型企业自动化主要在单元级，一般是人员密集型企业，自动化水平相对较低，柔性要求高。其产能主要由加工要素配置合理性决定，既有按订单生产，也有按库存生产。由于产品工艺过程经常变更，因此需要良好的计划能力，对工序级的作业调度需要考虑优先级、设备能力、均衡生产等多个方面，通过良好的作业顺序提高生产效率。从这个意义上来说，离散制造型企业通过软件改进来提升竞争力更具潜力。</p><p><strong>流程制造</strong>是经过一些列加工装置使原材料进行化学或物理变化得到最终产品，如化工、食品、制药、钢铁等制造业。流程制造分为重复生产和连续生产两种类型，区别在于重复生产可以将产品一个个分开。流程制造在每个工艺过程中会出现主产品、副产品、中间产品、回流物和废物等，上级物料和下级物料的数量关系可能随温度、压力、湿度、季节、人员技术水平、工艺条件的不同而变化。<br>流程制造主要特征为计划制定相对简单和稳定，工具和设备为专用产品而设计，专注于物料数量、质量和工艺参数的控制。<br>流程制造型企业大多采用大规模大批量的生产方式，工艺技术成熟，自动化水平较高，只有满负荷生产才能降低成本，因此企业年度生产计划更重要，作业调度不一定需要精确到工序。其产能主要由设备产能决定，设备维护尤为重要，主要采用按库存的生产方式，生产计划的依据主要是市场预测。</p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manufacture </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>注塑成型工艺</title>
      <link href="/2018/08/21/craft/craft-inj-mold/"/>
      <url>/2018/08/21/craft/craft-inj-mold/</url>
      <content type="html"><![CDATA[<p><strong>注塑成型</strong>又称注射模塑成型，在一定温度下，通过螺杆搅拌完全熔融的塑料材料，用高压射入模腔，经冷却固化后得到成品。该方法适用于形状复杂部件的批量生产。</p><p>注塑成型过程主要分为合模、射胶、保压、冷却、开模、取出六个阶段。常规材料主要有热塑性塑料，此外热固性塑料和橡胶等成型也可使用，但料筒温度较低、注射压力较高，需要模具加热、物料在模具中固化或硫化、趁热脱模等过程。</p><p>一模多穴是指一个模具生产多个产品；一机多模是指一个机器上放入多个模具，从而生产多个产品。</p><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> craft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> injection molding </tag>
            
            <tag> plastic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>金属加工工艺</title>
      <link href="/2018/08/20/craft/craft-machine/"/>
      <url>/2018/08/20/craft/craft-machine/</url>
      <content type="html"><![CDATA[<p>金属加工主要分为粗加工、精加工和热加工等方式。<strong>粗加工</strong></p><p><strong>细加工</strong>包括磨削、</p><p>车削、磨削、铣削、镗削、钻削都是常见的金属冷加工方式。<br><strong>热加工</strong>包括铸造、焊接、锻造、冲压等。</p><p><strong>车削</strong>是指利用工件的旋转运动和刀具的直线或曲线运动来改变毛坯形状和尺寸，适合加工回转表面，如内外圆柱面、圆锥面、沟槽、螺纹等。<strong>铣削</strong>是指将工件固定，用高速旋转的铣刀在毛坯上走刀。</p><p><strong>卧式机床</strong>主轴横卧，工件夹在卡盘上将负荷传递给主轴，优点是观察和操作方便，适合加工中小型轮盘和轴类。<strong>立式机床</strong>主轴直立，工件重量分散到床身上，优点是承重能力强、刚性好，时候加工直径大的工件。</p><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> craft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine </tag>
            
            <tag> metal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>know-iis</title>
      <link href="/2018/08/16/knowledge/know-iis/"/>
      <url>/2018/08/16/knowledge/know-iis/</url>
      <content type="html"><![CDATA[<p>—-To Be Continued—-</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>OPC数据访问</title>
      <link href="/2018/07/30/knowledge/know-opcdataaccess/"/>
      <url>/2018/07/30/knowledge/know-opcdataaccess/</url>
      <content type="html"><![CDATA[<p>OPC采用client/server模式，主要包括三部分：服务器(server)、组(group)和数据项(item)。<strong>服务器对象</strong>保存服务器和服务器作为OPC组对象容器的所有信息。<strong>组对象</strong>包括公共组和私有组两种，公共组由多个客户共享，私有组只隶属于一个OPC客户。OPC客户可以通过组对象来读写数据并设定OPC服务器应提供的数据更新速率。<strong>数据项对象</strong>是读写数据的最小逻辑单位，每个数据项包括值(value)、品质(quality)、和时间戳(timestamp)三个变量。</p><p>OPC数据访问主要有同步访问和异步访问两种方式。<strong>同步数据访问</strong>时，OPC服务器按照要求返回数据之前，OPC应用程序一直处于等待状态，在动作完成前不能执行任何应用程序侧的处理。<strong>异步数据访问</strong>时，对OPC服务器提出数据访问要求后立即返回到OPC应用程序中，服务器完成后通知OPC应用程序，从而得到数据访问结果。</p><p>C#中调用OPC主要使用自动化接口OPCAutomation.dll库。</p><ol><li>SyncR</li></ol><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强制停止Windows服务</title>
      <link href="/2018/07/24/tip/tip-killservice/"/>
      <url>/2018/07/24/tip/tip-killservice/</url>
      <content type="html"><![CDATA[<p>状态为Starting或Stopping的服务无法在Service桌面应用或任务管理器的Service选项卡中启动或停止，可以通过命令行taskkill指令进行强制停止。</p><pre><code>taskkill /PID 任务管理器中的服务PID /F</code></pre>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> service </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL Server备份还原</title>
      <link href="/2018/07/05/tip/tip-backup-data/"/>
      <url>/2018/07/05/tip/tip-backup-data/</url>
      <content type="html"><![CDATA[<ol><li><p>数据库整体备份/还原<br>右键数据库名-任务-备份/还原，将数据库整体备份到一个.bak文件中。</p></li><li><p>生成脚本还原<br>需要单独备份SQL Server中某些表、存储过程、函数等对象，或导出部分表格数据时，右键数据库名-任务-生成脚本，选择需要备份的对象，点击“高级”，在“要编写脚本的数据类型”项中选择“仅限架构”、“仅限数据”或“架构和数据”。</p></li></ol>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL Server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数字通信发展历史与展望</title>
      <link href="/2018/06/29/review/rev-mobilecomm/"/>
      <url>/2018/06/29/review/rev-mobilecomm/</url>
      <content type="html"><![CDATA[<p><img src="/2018/06/29/review/rev-mobilecomm/generation.jpg" alt="generations"></p><a id="more"></a><p>NOT DONE</p><p>LTE系统有两种制式：FDD-LTE和TDD-LTE，即频分双工LTE系统和时分双工LTE系统，二者技术的主要区别在于空中接口的物理层上（像帧结构、时分设计、同步等）。FDD-LTE系统空口上下行传输采用一对对称的频段接收和发送数据，而TDD-LTE系统上下行则使用相同的频段在不同的时隙上传输，相对于FDD双工方式，TDD有着较高的频谱利用率。</p>]]></content>
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> digital communication </tag>
            
            <tag> 5G </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>现场安全生产管理培训</title>
      <link href="/2018/06/26/training/train-safety/"/>
      <url>/2018/06/26/training/train-safety/</url>
      <content type="html"><![CDATA[<p>生产运作过程包括投入、转换、产出、反馈。<strong>生产管理</strong>是对生产运作系统的设计、运行和维护过程的管理。<br><strong>生产管理的基本问题</strong>包括产出要素管理、资源要素管理、环境要素管理等。<strong>产出要素管理</strong>包括质量、时间、成本、服务。<strong>资源要素管理</strong>包括设备设施管理、物料管理、人力资源管理、信息管理。<br><strong>生产效率</strong>，又称作业能率，是指实际产量与标准产量的比率。</p><h2><span id="1-现场管理">1. 现场管理</span></h2><p><strong>现场管理的核心内容</strong>就是提高人的业务效率，并可以应对现场工作环境的改变。<strong>优化现场管理的实质</strong>是改善存在的差距。</p><h3><span id="6s管理方法">6S管理方法</span></h3><p><strong>整理（SEIRI）</strong>将工作场所的任何物品区分为有必要和没有必要的，除了有必要的留下来，其他的都消除掉。<br><strong>整顿（SEITON）</strong>把留下来的必要用的物品依规定位置摆放，并放置整齐加以标识。<br><strong>清扫（SEISO）</strong>将工作场所内看得见与看不见的地方清扫干净，保持工作场所干净、亮丽的环境。<br><strong>清洁（SEIKETSU）</strong>将整理、整顿、清扫进行到底，并且制度化，经常保持环境处在美观的状态。<br><strong>素养（SHITSUKE）</strong>每位成员养成良好的习惯，并遵守规则做事，培养积极主动的精神（也称习惯性）。<br><strong>安全（SECURITY）</strong>重视成员安全教育，每时每刻都有安全第一观念，防患于未然。 </p><h3><span id="现场管理五大要素">现场管理五大要素</span></h3><p>提高生产效率、产品质量以及预防安全事故都离不开人、机、料、法、环这五大要素。<br><strong>人（Man）</strong>就是指在现场的所有人员，是现场管理中最大的不可控因素。<br><strong>机（Machine）</strong>就是指生产中所用的设备、工具等。<br><strong>料（Material）</strong>就是指物料、备件、半成品等<br><strong>法（Method）</strong>是指制造产品所使用的方法、技术。<br><strong>环（Environment）</strong>是指生产现场的环境。</p><h2><span id="2-班组管理">2. 班组管理</span></h2><p><strong>班组</strong>是企业组织生产经营活动的基本单位，是企业最基层的生产管理组织，班组执行程度的好坏直接影响公司产品品质。<strong>班组管理的基本内容</strong>是人、财、物、信息、时间。班组规范化管理中的三定是<strong>定岗、定责、定薪</strong>。</p><p><strong>班组创新管理的主要方式</strong>，按照变革的幅度划分有：渐进式创新、突变式创新、开拓式创新；按照自主性程度划分有：跟随式创新、自主式创新。<br><strong>班组常用的激励方法</strong>有需要激励法、强化激励法、目标激励法和公平激励法。</p><p><strong>班组长</strong>是企业的生产管理者。<br><strong>班组长管理的基本原则</strong>是职工本位原则、系统性原则、激励原则、效益原则、目标管理原则、质量第一原则。班组长每天上班第一件事是<strong>去生产现场</strong>。<br><strong>班组建设最有效的手段</strong>是自身示范，其次是培训。班组培训包括生产技能培训、规章制度培训、安全培训、应急问题能力培训、创新能力培训等。</p><p><strong>沟通的两个基本原则</strong>是目标关注和角色定位。<br><strong>下达命令的三大原则</strong>是任务明确具体、确认下属了解程度、激发下属执行意愿。</p><p><strong>召开班前会的目的</strong>包括营造工作气氛、进行工作安排、员工的教育和指导、传递公司信息等。</p><p><strong>班组安全员</strong>对本班组的<strong>班组人员关系</strong>等情况比较熟悉，工作更具有针对性和实效性。</p><h2><span id="3-质量管理">3. 质量管理</span></h2><p>质量概念涵盖的对象是一切可单独描述和研究的事物。<strong>质量环</strong>是对产品质量的产生、形成和实现过程进行的抽象描述和理论概括。<br>影响产品质量的异常因素是可以发现和消除的。质量检验的实质是<strong>事后把关</strong>。质量检查的<strong>三检制</strong>指自检、互检、专检。<br><strong>质量管理的三个阶段</strong>为质量检验阶段、统计质量控制阶段、全面质量管理阶段。<strong>统计质量控制阶段</strong>的重点主要是确保产品质量符合规范和标准。<br><strong>全过程质量管理</strong>认为质量产生、形成和实现的过程中每个环节都影响最终的质量情况。</p><p><strong>PDCA循环</strong>，P-Plan计划，确定方针和目标；D-Do执行，实现计划中的内容；C-Check检查，总结执行计划的结果，找出问题；A-Action行动，对总结检查的结果进行处理。</p><h2><span id="4-安全管理">4. 安全管理</span></h2><p><strong>安全</strong>是生产系统中的人员免遭不可承受危险的伤害。<strong>安全生产</strong>是专指国家对劳动者在劳动生产过程中可能引起伤亡的保护。<br><strong>安全管理目标</strong>包括生产安全事故控制目标、安全达标目标、文明施工实现目标等。<strong>安全管理的实施程序</strong>，第一步是危害辨别，第二步时危险评估，第三步是危险控制。<br>我国的安全工作方针是<strong>安全第一、预防为主、综合治理</strong>。</p><p><strong>本质安全</strong>是指通过设计等手段使生产设备或生产系统本身具有安全性。具体包括失误—安全（误操作不会导致事故发生或自动阻止误操作）、故障—安全（设备、工艺发生故障时还能暂时正常工作或自动转变安全状态）。</p><p><strong>安全标志</strong>是用于表达特定信息的标志，由（图形符号、安全色、几何图形、文字）组成。<br><strong>劳防用品</strong>分为一般劳动防护用品和特种劳动防护用品。</p><h3><span id="安全生产法">安全生产法</span></h3><p>安全生产法律体系既包括宪法规范（安全生产法律法规基础），也包括行政法律法规、技术性法律法规、程序性法律法规。<br><strong>《安全生产法》</strong>是对<strong>所有生产经营单位</strong>的安全生产普遍使用的基本法律。</p><p>生产经营单位最基本的安全管理制度是<strong>安全生产责任制</strong>。</p><p>生产经营单位的责任和义务包括：</p><ol><li>必须对安全设备进行<strong>经常性</strong>维护、保养</li><li>生产、经营、储存、使用危险品的车间、商店、仓库不得与员工宿舍在同一座建筑物内</li><li>生产经营单位负责人对本单位的安全生产工作全面负责</li><li>生产经营单位负责人接到事故报告后，应当迅速采取有效措施并组织抢救</li><li>对同一个项目的多个承包单位承租的安全生产工作实施<strong>统一协调、管理</strong></li></ol><p>从业人员在安全生产方面的权利包括：</p><ol><li>依法获得社会保险的权利</li><li>了解作业场所和岗位存在危险因素的权利</li><li>了解事故防范和应急措施，并对本单位<strong>安全生产工作</strong>提出意见和建议</li><li>对安全生产工作中存在的问题提出批评、检举和控告的权利，有权拒绝<strong>违章指挥</strong>和<strong>强令冒险作业</strong></li><li>发现直接危及人身安全的紧急情况时，有权进行<strong>紧急避险</strong></li><li>因生产安全事故受到损害时，除依法享有工伤社会保险外，还有依照民事法律相关规定，向本单位提出赔偿要求的权利</li></ol><p>从业人员在安全生产方面的义务包括：</p><ol><li>遵守国家有关安全生产方面的法律、法规和规章</li><li>作业过程中，严格遵守本单位<strong>安全生产规章制度和操作规程</strong>，服从安全生产管理</li><li>作业过程中，正确佩戴和使用<strong>劳动防护用品</strong></li><li>自觉接受生产经营单位有关安全生产的<strong>教育和培训</strong>，掌握所从事工作应当具备的安全生产知识</li></ol><h3><span id="事故处理">事故处理</span></h3><p><strong>事故隐患</strong>泛指生产系统中导致事故发生的人的不安全行为、物的不安全状态和管理上的缺陷等，分为一般事故隐患和重大事故隐患。</p><p>事故按照性质可以分为责任事故、非责任事故和破坏事故。<br>生产安全事故的调查应坚持<strong>“四不放过”原则</strong>，即：</p><ol><li>事故原因未查清不放过</li><li>事故责任人未受到处理不放过</li><li>事故责任人和周围群众未受到教育不放过</li><li>事故没有制定切实可行的整改措施不放过</li></ol><h3><span id="安全知识">安全知识</span></h3><p>发生触电事故的危险电压一般是从<strong>65V</strong>开始。</p>]]></content>
      
      <categories>
          
          <category> training </category>
          
      </categories>
      
      
        <tags>
            
            <tag> safety </tag>
            
            <tag> management </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络互连设备及作用</title>
      <link href="/2018/06/26/knowledge/know-networkdevice/"/>
      <url>/2018/06/26/knowledge/know-networkdevice/</url>
      <content type="html"><![CDATA[<p>两个网络实现互访和通信，需要转换两者协议、处理速率和带宽差别等，解决这些问题并进行协调、转换的设备就是<strong>网络互连设备</strong>，包括网卡、中继器、集线器、网桥、交换机、路由器、网关等。两个网络实现通信的难度取决于两者的差别程度，与OSI七层模型关系密切。</p><a id="more"></a><p>NOT DONE<br><!--more--><br>网卡<br>中继器<br>集线器<br>网桥<br>交换机<br>路由器<br>网关</p><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network basis </tag>
            
            <tag> transmission devide </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>扩展虚拟机存储空间</title>
      <link href="/2018/06/25/tip/tip-vm-extend/"/>
      <url>/2018/06/25/tip/tip-vm-extend/</url>
      <content type="html"><![CDATA[<p>扩展虚拟机存储空间分为两类：</p><ol><li>仅仅空间不够用，可以添加一块新的虚拟硬盘，进入虚拟机后用磁盘管理配置为一个新盘符</li><li>扩展系统盘空间，使用VMWare中的工具（实用工具——扩展容量），可以扩展容量的磁盘不可以有快照（快照管理器——删除快照），同时虚拟磁盘文件不可以分成多个文件存储</li></ol><p>若扩展磁盘容量时提示“<strong>在部分链上无法执行所调用的函数，请打开父虚拟磁盘</strong>”，报错是由于虚拟磁盘分成多个文件存储，无法直接扩容，解决方法如下：</p><ol><li>在VMWare中选中该磁盘，确定需要转换的磁盘文件名并关闭 </li><li>打开DOS窗口，进入VMWare安装目录</li><li><p>输入命令</p><pre><code>vmware-vdiskmanager.exe -r &quot;虚拟磁盘文件旧.vmdk&quot; -t 0 &quot;虚拟磁盘文件新.vmdk&quot;</code></pre></li><li><p>合并完成后可以将新生成的单个虚拟磁盘文件替换原有多个虚拟磁盘文件</p></li><li>重新打开VMWare，选择扩容虚拟磁盘即可</li></ol><p>Reference <a href="https://blog.csdn.net/xx033138/article/details/78568985" target="_blank" rel="noopener">VMware:在部分链上无法执行所调用的函数，请打开父虚拟磁盘</a></p>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual machine </tag>
            
            <tag> VMWare </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>虚拟机三种网络连接模式</title>
      <link href="/2018/06/12/knowledge/know-vm-network/"/>
      <url>/2018/06/12/knowledge/know-vm-network/</url>
      <content type="html"><![CDATA[<p>VMware虚拟机有三种网络模式，分别是<strong>桥接模式(Bridged)</strong>、<strong>网络地址转换模式(NAT)</strong>、<strong>仅主机模式(Host-only)</strong>。</p><p>安装完成VMWare之后会自动生成三个虚拟网络，其中VMnet0用于桥接模式，VMnet1用于仅主机模式，VMnet8用于NAT模式，后两者提供DHCP服务不需要手动设定IP。</p><ol><li><p>桥接模式<br>该模式下虚拟机就像局域网中一台独立的主机，在分配局域网所要求的网络地址、子网掩码、网管等之后，与宿主计算机所在网络的其他计算机都可以互相访问。<br>若希望利用VMWare在局域网内建立虚拟服务器并为局域网用户提供网络服务，就应该选择桥接模式。<br>如果出现主机不能ping通虚拟机的情况，可以查看主机的防火墙的入站规则中对ICMP协议相关的配置文件是否启用。<br><img src="/2018/06/12/knowledge/know-vm-network/vmware_network_bridged.png" alt="bridged"></p></li><li><p>NAT模式<br>该模式下虚拟机网卡连接到宿主计算机VMnet8网卡上，加设了一个虚拟的NAT服务器，虚拟机可以与宿主计算机互访，对外访问时使用的时宿主机的IP地址，而外部无法访问虚拟机。<br>若希望将虚拟机连接外部网络，这种模式最简单，不需要做任何网络设置。<br><img src="/2018/06/12/knowledge/know-vm-network/vmware_network_nat.png" alt="bridged"></p></li><li><p>仅主机模式<br>该模式下虚拟机网卡连接到宿主计算机VMnet1网卡上，虚拟机只能与宿主计算机互访。<br>若希望创建与网内其他机器隔离的虚拟系统，进行特殊的网络调试工作，可以使用仅主机模式。<br><img src="/2018/06/12/knowledge/know-vm-network/vmware_network_hostonly.png" alt="bridged"></p></li></ol><p>Reference<br><a href="https://blog.csdn.net/collection4u/article/details/14127671" target="_blank" rel="noopener">Vmware虚拟机下三种网络模式配置</a><br><a href="http://penpenguanguan.com/337.html" target="_blank" rel="noopener">理解VMWare的三种网络连接模式(bridged、NAT、host-only)</a></p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual machine </tag>
            
            <tag> VMWare </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Transact-SQL中变量的作用范围</title>
      <link href="/2018/06/05/tip/tip-sql-declare/"/>
      <url>/2018/06/05/tip/tip-sql-declare/</url>
      <content type="html"><![CDATA[<p>与常见的高级语言不同，Transact-SQL中局部变量的作用域是所在的<strong>批处理</strong>，在IF语句内定义的变量在IF外仍可继续使用，而由于Transact-SQL是以GO语句来区分批处理的，在下一个GO之后无法继续使用。<br>具体示例见参考链接。</p><p>Reference <a href="http://www.cnblogs.com/breezeli/archive/2010/04/16/1713308.html" target="_blank" rel="noopener">SQL中declare变量的作用域</a></p>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL Server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>___FTTM中的软件Bug</title>
      <link href="/2018/05/25/tip/tip-ftld-bug/"/>
      <url>/2018/05/25/tip/tip-ftld-bug/</url>
      <content type="html"><![CDATA[<p>在使用FactoryTalk Transaction Manager过程中，有时会遇到双击配置Live Data Connector时整个程序没有响应的情况，排除可能的问题包括：</p><ol><li>两个Configuration中重名的Connector</li><li>选择不存在的FactoryTalk View SE程序</li><li>打开FactoryTalk View SE服务器和客户端的顺序</li><li>Kepserver OPC服务器安装</li><li>硬盘剩余容量小</li></ol><p>这些情况都不会造成软件崩溃。<br>在一次尝试中意外复现了该问题，证明如下操作会造成Live Data Connector无法配置：<br>对于一个未绑定FactoryTalk View SE程序的Live Data Connector，双击初次配置并选择程序的过程中<strong>不可以</strong>选择“Cancel取消”，<strong>可以</strong>任意选择一个程序后在导入标签的页面选择“Close关闭”，否则FactoryTalk Transaction Manager会立即崩溃，再次打开可以启动自身或其他Configuration中的服务，但无法更改任何Live Data Connector的配置。</p><p>软件版本：<br>Windows Server 2008 R2<br>FactoryTalk Service Platform 2.74.00 (CPR9 SR7.4)<br>FactoryTalk Transaction Manager 10.10.00</p>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FactoryTalk </tag>
            
            <tag> Rockwell </tag>
            
            <tag> Transaction Manager </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《工业控制网络》笔记</title>
      <link href="/2018/05/25/note/note-industrial/"/>
      <url>/2018/05/25/note/note-industrial/</url>
      <content type="html"><![CDATA[<p><strong>《工业控制网络》 主编：王振力 人民邮电出版社 2012年1月第1版 TP273 ISBN: 978-7-115-30136-9 </strong><br>本书介绍了工业控制网络的特点、发展历程、技术现状和发展趋势，重点介绍了Modbus、Profibus、CAN、DeviceNet及CANopen等现场总线技术，还介绍了EAP、Profinet、HSE、EtherNet/IP及Modbus-TCP等工业以太网技术，并结合台达工业自动化产品有针对性地安排了大量工业控制网络应用案例和实验内容。<br><a id="more"></a></p><!-- toc --><ul><li><a href="#第一章-绪论">第一章 绪论</a><ul><li><a href="#11-工业自动控制系统历史">1.1 工业自动控制系统历史</a></li><li><a href="#12-工业控制网络特点">1.2 工业控制网络特点</a></li><li><a href="#13-传统控制网络现场总线">1.3 传统控制网络：现场总线</a></li><li><a href="#14-现代控制网络工业以太网">1.4 现代控制网络：工业以太网</a></li><li><a href="#16-工业控制网络发展趋势">1.6 工业控制网络发展趋势</a></li></ul></li><li><a href="#第二章-数据通信与网络基础">第二章 数据通信与网络基础</a><ul><li><a href="#21-数据通信系统概述">2.1 数据通信系统概述</a></li><li><a href="#22-数据编码技术">2.2 数据编码技术</a></li><li><a href="#24-工业控制网络的节点">2.4 工业控制网络的节点</a></li><li><a href="#通信传输介质">通信传输介质</a></li></ul></li></ul><!-- tocstop --><h2><span id="第一章-绪论">第一章 绪论</span></h2><h3><span id="11-工业自动控制系统历史">1.1 工业自动控制系统历史</span></h3><p>20世纪50年代前 - <strong>模拟仪表控制系统(Analog Control System, ACS)</strong>：精度低、干扰大<br>20世纪60年代起 - <strong>直接数字控制系统(Direct Digital Control, DDC)</strong>：中心计算机可靠性差<br>20世纪70年代起 - <strong>集散式控制系统(Distributed Control System, DCS)</strong>：电缆多、互操作性差<br>20世纪90年代起 - <strong>现场总线控制系统(Fieldbus Control System, FCS)</strong>：成本低、通信可靠</p><h3><span id="12-工业控制网络特点">1.2 工业控制网络特点</span></h3><p>工业控制网络是3C技术(Computer,Communication,Control)发展汇集成的结合点，是信息技术、数字化、智能化网络发展到现场的结果，是一类特殊的网络，与传统信息网络相比有如下特点：</p><ol><li>应用于工业现场，对环境要求高</li><li>包含多种复杂、异构的节点，多为嵌入式CPU</li><li>主要任务为传输工业数据、承担自动测控任务，实时性要求高</li></ol><h3><span id="13-传统控制网络现场总线">1.3 传统控制网络：现场总线</span></h3><p>现场总线技术源于欧洲，目前以欧美日地区最为发达，经过近20年的竞争和完善，目前较有生命力的有10多种，并仍处于激烈的市场竞争中。诞生于不同领域的总线技术往往对特定领域的适用性较好，如Profibus较适合工厂自动化、CAN适合汽车工业、FF适用于过程控制、LonWorks适用于楼宇自动化等。</p><h3><span id="14-现代控制网络工业以太网">1.4 现代控制网络：工业以太网</span></h3><p>工业以太网是在以太网技术和TCP/IP技术的基础上发展起来的一种工业控制网络。由于现场总线多种标准并存，异种网络通信困难，以太网进入工业自动化领域并快速发展。<br>以太网是在1972年发明的，并于1982年公布了以太网规范，IEEE802.3就是以这个技术规范为基础制定的。以太网技术具有成本低、通信速率和带宽高、兼容性好、软硬件资源丰富等诸多优点。<br>将工业以太网引入工业控制领域，主要有以下优点：</p><ol><li>采用TCP/IP国际标准，协议开放，互连和互操作性强</li><li>可实现远程访问和诊断</li><li>网络速度快，不同传输介质可以灵活组合</li><li>指出冗余连接配置，数据可达性强</li><li>成熟可靠的系统安全体系</li></ol><p>同时工业以太网也存在实时性、可靠性、安全性、总线供电等问题。</p><h3><span id="16-工业控制网络发展趋势">1.6 工业控制网络发展趋势</span></h3><p>纵观当今工业控制网络的发展趋势和市场需求，未来工业控制网络发展方向包括：</p><ol><li>提高通信的实时性：操作系统和交换技术的实时性</li><li>提高通信的可靠性：虚拟自动化网络</li><li>提高通信的安全性：黑通道机制和安全完整性等级SIL</li><li>多现场总线集成：<a href="/2018/05/17/introduction/intro-opc/" title="OPC及OPC UA技术">OPC及OPC UA技术</a></li><li>无线网络技术应用：工业WLAN协议(IEEE802.11n)、蓝牙(IEEE 802.15.1)和ZigBee(IEEE 802.15.4)</li></ol><h2><span id="第二章-数据通信与网络基础">第二章 数据通信与网络基础</span></h2><h3><span id="21-数据通信系统概述">2.1 数据通信系统概述</span></h3><p><strong>数据通信系统</strong>一般由信息源与信宿、发送与接收设备和传输介质几部分组成。<strong>信源和信宿</strong>是信息的产生者和使用者；<strong>发送设备</strong>将信息源产生的消息信号经过编码变换为便于传送的信号形式并送往传输介质；<strong>接收设备</strong>的任务是从带有干扰的信号中正确恢复出原始信息，解除多路复用等；<strong>传输介质</strong>指发送设备到接收设备之间的信号传递所经的媒介。<br><img src="/2018/05/25/note/note-industrial/comm_model.JPG" alt="comm_system"></p><p>衡量数据通信系统性能的指标包括：</p><ol><li><strong>误码率</strong>，二进制数据被错误传输的概率</li><li><strong>传输速率</strong>，单位时间内传送二进制数据的位数</li><li><strong>协议效率</strong>，所传数据包中有效二进制数据位数与所传输的总位数之比</li></ol><p>总体来说通信协议越简单，协议效率越好，但往往无法满足可靠性要求。</p><h3><span id="22-数据编码技术">2.2 数据编码技术</span></h3><p>在信息源中将原始的信息转换成代码表示的数据过程称为<strong>信源编码</strong>，如BCD码、ASCII码、汉字区位码等。<strong>信道编码</strong>是将信源编码变换到某种适合于信道传输的信号形式。</p><p>数字信号可以通过调制和解调在模拟通信信道中传输，根据所控制的载波参数不同分为幅移键控法(ASK)、频移键控法(FSK)和相移键控法(PSK)。</p><p>数字信号编码方法很多，信号电平有正负两种极性的称为<strong>双极性码</strong>，只有一种极性称为<strong>单极性码</strong>；信号电平在每位二进制数传输时间内都返回零电平的称为<strong>归零码</strong>，与之对应信号电平保持的称为<strong>不归零码</strong>，最普遍采用的信号编码方法为单极性不归零码。</p><h3><span id="24-工业控制网络的节点">2.4 工业控制网络的节点</span></h3><p><strong>可编程控制器</strong>，工业控制网络中不可或缺的设备，大多支持多种现场总线和工业以太网。<br><strong>传感器</strong>将检测感受到的信号按一定规律变换成标准信号，<strong>变送器</strong>将传感器输出信号转换为可以被控制器接受的标准信号。仪器仪表公司为了适应工业控制网络的需求，设计了智能型传感器与变送器，通过嵌入式微处理器实现现场总线和工业以太网的通信接口。<br><strong>执行器</strong>是过程控制系统中对被控对象施加控制作用的仪表，<strong>驱动器</strong>是运动控制系统中驱动各种电动机的装置。工业控制中使用最多的执行器和驱动器包括电动调节阀、变频器和伺服驱动器。<br><strong>人机界面</strong>泛指控制系统与操作人员交换信息的设备。<br><strong>网络互连设备</strong>是工业控制网络互联互通的关键，主要包括网卡（网络适配器）、中继器、集线器、网桥、交换机、路由器和网关。</p><h3><span id="通信传输介质">通信传输介质</span></h3><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> communication basis </tag>
            
            <tag> industrial control </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OPC及OPC UA技术</title>
      <link href="/2018/05/17/introduction/intro-opc/"/>
      <url>/2018/05/17/introduction/intro-opc/</url>
      <content type="html"><![CDATA[<p>OPC是一个工业标准，属于<a href="https://opcfoundation.org/" target="_blank" rel="noopener">OPC基金会</a>，现有会员已超过220家，包括世界上所有主要的自动化控制系统、仪器仪表及过程控制系统的公司。</p><p>经典OPC规范基于微软Windows系统提供的COM/DCOM技术，用于软件之间数据交换的规范。OPC规范定义了几种不同的，用于访问过程数据、报警信息以及历史数据的版本规范：<br>OPC实时数据访问规范（OPC DA）定义了包括数据值，更新时间与数据品质信息的相关标准。<br>OPC历史数据访问规范（OPC HDA）定义了查询、分析历史数据和含有时标的数据的方法。<br>OPC报警事件访问规范（OPC AE）定义了报警与时间类型的消息类信息，以及状态变化管理等相关标准。</p><p>基于COM/DCOM的技术有着不可根除的缺点，因此随着技术的进步，以及数据交换各方面需求的提高，OPC基金会在2008年发布了新的规范：OPC UA。</p><p>OPC UA规范不再是基于COM/DCOM技术，因此OPC UA不仅能在Windows平台上实现，更可以在Linux，以及其他的嵌入式平台中实现。与传统OPC规范相同，OPC UA 同样有着相同的设计目标：</p><ol><li>功能等价：所有的基于COM的OPC规范中的功能，都映射到了OPC UA中。</li><li>多平台支持：支持从嵌入式的微控制器到基于云的分散式控制架构。</li><li>安全：信息加密，互访认证以及安全监听功能。</li><li>扩展性：不影响现有应用程序的情况下，就可以添加新的功能。</li><li>丰富的信息建模：可定义复杂的信息，而不再是单一的数据。</li></ol><p>相比于传统OPC，OPC UA具有以下特点：<br>一、功能方面，OPC UA不仅支持传统OPC的所有功能，更支持更多新的功能：1. 网络发现：自动查询本PC机中与当前网络中可用的OPC Server。2. 地址空间优化：所有的数据都可以分级结构定义，使得OPC Client不仅能够读取并利用简单数据，也能访问复杂的结构体。3. 互访认证：所有的读写数据/消息行为，都必须有访问许可。4. 数据订阅：针对OPCClient不同的配置与标准，提供数据/消息的监控，以及数值变化时的变化报告。5. 方案(Methods)功能：OPC UA中定义了通过在OPCServer中定义方案（Methods），来让OPC client执行特定的程序。<br>二、平台支持方面，由于不再基于COM/DCOM技术，OPC UA标准提供的更多的可支持的硬件或软件平台。硬件平台诸如传统的PC机、基于云的服务器、PLC、ARM等其他微处理器；而软件平台可支持微软的Windows、苹果公司的OSX、安卓，以及其他的基于Linux的分布式操作系统。<br>三、安全性方面，最大的变化是OPC UA可以通过任何单一端口（经管理员开放后）进行通信，这使得OPC通信不再会由于防火墙受到大量的限制</p><p>1、OPC UA在传输中可通过XML格式或者二进制格式来传输，并且可选择并兼容更多通用的IT通信协议，比如HTTPS。同时，在加密时，也能达到128或者256位的加密深度。在客户端与服务器的通信许可方面，OPC UA使用了OpenSSL许可证来规定哪些应用程序或系统可以使用OPC与另一端相连接。2、在建模方面，OPC UA将建模的架构由“数据建模”扩展为了“信息建模”。OPC UA规范中不仅仅提供了完整的面向对象的数据建模，同时也可定义复杂的多级结构体。数据类型或结构体都在配置文件（profiles）中定义，不仅可以定义已存在的传统OPC规范中的类型，还可以扩展加入其他的供应商或组织定义的新类型。</p><p><a href="http://blog.sina.com.cn/s/blog_a68809ea0102vk1p.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_a68809ea0102vk1p.html</a></p><p>【1. OPC UA 规范组成】</p><p>OPC统一体系架构规范由十一部分组成。各部分规范概要介绍如下：</p><p>第一部分——概念<br>这部分规范描述了关于OPC UA 服务器和客户端的基本概念。</p><p>第二部分——安全模型<br>这部分规范描述了用于OPC UA客户端和OPC UA服务器之间安全交互的模型。</p><p>第三部分——地址空间模型<br>这部分规范描述了服务器地址空间的内容和结构。</p><p>第四部分——服务<br>这部分规范指定了OPC UA服务器提供的所有服务。</p><p>第五部分——信息模型<br>详细说明了为OPC UA服务器定义的标准数据类型和它们之间的关系。</p><p>第六部分——映射<br>这部分规范详细说明了OPC UA支持的传输映射和数据编码机制。</p><p>第七部分——协议<br>这部分规范详细说明了可用于OPC客户端和服务器的协议。这些协议提供了可用于一致性标准的服务和功能。服务器和客户端可依靠这些协议来进行测试。</p><p>第八部分——数据访问<br>详细说明了如何使用OPC UA进行数据访问。</p><p>第九部分——报警与事件<br>详细说明了使用OPC UA对报警与条件通道的支持。基本的系统包括对简单事件的支持；这部分规范拓展了对报警与事件的支持。</p><p>第十部分——程序<br>详细说明了OPC UA对程序访问的支持。</p><p>第十一部分——历史数据访问<br>详细说明了使用OPC UA对历史信息的访问。访问包括对历史数据和历史事件的访问。</p><p>【2. OPC UA 规范总貌】</p><p>2.1 介绍<br>OPC统一体系结构是一个不依赖任何平台的标准，借助此标准各种各样的系统和设备能在不同的网络中以C/S的模式进行通信。OPC统一体系结构通过确认客户端和服务器的身份和自动抵御攻击来支持稳定的、安全的通信。OPC UA定义了一系列服务器所能提供的服务，特定的服务器需要向客户端详细说明它们所支持的服务。信息通过使用标准的和宿主程序定义的数据类型进行表达。服务器定义客户端可识别的对象模型。服务器可以提供查看实时数据和历史数据的接口，并且由报警和事件组件来通知客户端重要的变量或事件变化。OPC UA可以被映射到一种通信协议上并且数据可以以不同的形式进行编码来达到传输便捷和高效的目的。</p><p>2.2 设计目标</p><p> OPC UA提供了一个一致的、完整的地址空间和服务模型。这就允许一个单一的OPC UA服务器把数据，报警与事件和历史信息统一到它的地址空间里，并且可以用一套统一的服务为它们向外提供接口。这些服务也包括一个统一的安全模型。</p><p>对于地址空间中要被访问的对象，OPC UA也允许服务器给客户端提供类型定义。这使得标准信息模型可以被用来描述地址空间的内容。OPC UA允许数据以不同的格式暴露出来，包括二进制结构和XML文档。数据格式可能被OPC或其他标准组织和厂商定义。通过地址空间，客户端能向服务器查询描述了数据格式的元数据。在许多情况下，没有数据格式编程知识的客户也能够在运行时刻决定数据格式并能恰当的使用数据。</p><p> OPC UA扩充了对节点间关联的支持而不是把节点限制在单一的层面上。这样就使得，一个OPC UA服务器能从不同的层面提供数据，来满足客户端有选择性查看数据的要求。这种灵活性，不仅融合了对类型定义的支持，而且使得OPC UA适用于更宽泛的领域。所以，OPC UA不仅致力于现场遥测的服务层面，而且在上层管理功能上也提供了更好的互用性。</p><p>OPC UA的目标是源源不断地提供已公布的数据。所有OPC服务器的一个主要特色就是发布数据和事件通知。OPC UA为客户端提供的机制可以使其快速检测到传输过程中的错误，并从中恢复过来，而不用等到底层协议所设定的超时时间结束。</p><p>OPC UA目标也要支持更广泛的服务器，从底层的PLC到企业服务器。从容量，性能，执行平台和功能上区分这些服务器。因此，OPC UA定义了一系列功能，不同的服务器可能只实现所有功能中的某些功能。为了推动互操作性，OPC UA定义了标准子集，与协议相关，以保证不同服务器的一致性。客户随后可以得到一个服务器的协议，然后依靠协议来和服务器进行交互。规范的第七部分详细说明了协议。</p><p>把OPC UA规范划分成不同的部分是为了把核心设计从底层的运算处理和网络传输分离出来。这使得OPC UA在不改变基础设计的情况下，被运用到未来技术上称为可能。映射和数据编码被定义在规范的第六部分。这里也定义了两种数据编码形式：1、可扩展标记语言/文本形式；2、UA 二进制形式。另外，这部分规范给出了两种传输协议：1、TCP（传输控制协议）；2、运用于HTTP（超文本传输协议）之上的网络服务简单对象访问协议。</p><p>由于客户端和服务器支持多种传输形式和编码形式，这使得最终用户可以在实施阶段来确定性能和网络服务兼容性之间的平衡点，而不是由OPC厂商在生产定义阶段确定其平衡点。</p><p>OPC UA的设计对于基于微软COM技术的OPC客户端和服务器来说，是可移植的。可移植性在设计OPC UA的时候已经给予了考虑，以至于由OPC COM服务器（数据访问，历史数据访问和事件报警）暴露出来的数据可以通过OPC UA进行映射和暴露出来。生产厂商既可以直接遵循OPC UA标准移植他们的产品，也可以对先前的产品进行外部封装来达到从OPC COM到OPC UA的过渡。先前每种OPC规范都是定义自己的地址空间和相应服务。OPC UA用一套服务把先前的各种模型统一到一个单一的地址空间里。</p><p>2.3 统一的模型和服务<br>2.3.1 安全模型<br>2.3.1.1 概要</p><p>OPC UA安全性主要考虑：客户端和服务器的合法性，用户的合法性，客户端和服务器之间通信的一致性和机密性，功能发布的真实性。OPC UA安全性不指定包含了多种必需安全机制的环境。安全模型规范是非常重要的，但是它可能在特定条件下由系统的设计者来制定，也可能由其他标准来指定。</p><p>另外，OPC UA提供了一个安全模型，规范的第二部分给予了定义，安全方法可以针对给定设备进行选择和配置来满足其安全性需要。安全模型包括标准安全机制和参数。在某些情况下，用于交换安全参数的机制需要定义，但是运用这些参数的方法不用定义。框架也定义了所有UA服务器必须支持的最少安全功能子集，即使这个功能子集中的功能没有被用在所有设备中。规范的第七部分定义了安全性协议。</p><p>2.3.1.2 建立会话</p><p>应用程序级的安全性依靠一个安全的通信通道，这个通信通道在应用程序会话过程中始终有效，并且保证所有被交换信息的完整性。这也就意味着用户在应用程序会话建立时进行一次认证就可以了，不需要第二次认证。规范的第四部分和第六部分定义了建立安全通道和应用程序会话的机制。</p><p>当一个会话建立时，客户端和服务器应用程序协商构造一个安全通信通道并且交换表明客户端和服务器身份的软件认证书还要交换各自所能提供功能的信息。OPC基金会发布的软件认证书显示了OPC UA中应用程序需要实现的基本要求，而且OPC UA认证标准贯彻到了每个协议中。规范的第七部分详细说明了每个协议和认证书的细节。由其他组织发行的认证也可能在会话建立期间进行交换。</p><p>会话建立之后，服务器会对用户身份进行鉴别，随后批准用户对服务器中对象访问的请求。诸如访问控制列表这样的授权机制，OPC UA规范没有给予详细说明。这些机制与特定的应用程序或系统有关。</p><p>2.3.1.3 审核</p><p>在客户端和服务器审查日志可查的条件下，用户级安全性为安全审查记录提供支持。如果在服务器端检测到一个安全连接问题，与之关联的客户端将在其审查日志中添加相应条目。OPC UA也为服务器提供了产生审查事件通知的功能，审查事件通知可以向有能力处理和记录审查事件的客户端报告审查性的事件。OPC UA定义了标准审查参数，审查日志和审查事件通知都可以包含这些参数。规范的第五部分定义了这些参数的数据类型。并不是所有的服务器和客户端都提供所有的审查特性。规范第七部分的协议显示了所要支持的审查特性。</p><p>2.3.1.4 传输安全性</p><p>OPC UA安全性弥补了大部分网络服务可选平台上底层结构安全性的不足。传输级别上的安全性可以用来加密并标记消息。加密和标记技术防止了信息的泄露，保证了消息的完整性。用于在OPC UA应用程序之间传递消息的底层通信技术提供了加密功能。规范的第七部分定义了用于给定协议上的加密和标记方法。</p><p>2.3.2 统一的地址空间模型</p><p>OPC UA服务器为客户端提供的对象和相关信息都是与服务器的地址空间有关的。OPC UA地址空间是以一组用引用形式连接起来的节点来描绘它的内容的。</p><p> OPC定义的属性描述了节点的原始特性。属性仅仅是一个服务器中拥有数值的元素。用来定义属性值的数据类型既可以是简单数据类型也可以是高级数据类型。</p><p>依照地址空间中节点的用途和含义，把它们进行分类。节点类为OPC UA的地址空间定义了元数据。规范的第三部分定义了OPC UA节点类。</p><p>节点基类定义了所有节点的公共属性。包括认证，分类和命名。每个节点类继承这些属性并可以另外定义自己的属性。</p><p>为了提高客户端和服务器的互操作性，在对所有服务器进行最高级标准化的条件下，对OPC UA的地址空间进行分层组织。尽管地址空间中的节点经过分层后，是相对独立唯一的，但是节点之间可能存在引用关系。这就使得地址空间可以描绘出一个相关联的节点网络。规范的第三部分定义了地址空间模型。</p><p>OPC UA服务器把地址空间以视点的形式划分成不同的子集，以此向客户端扩充自己的访问通道。3.3.3.3展示了地址空间视点的更多细节。</p><p>2.3.3 统一的对象模型</p><p>OPC UA对象模型提供了一套一致的、完整的节点类来描述地址空间中的对象。模型中根据对象包含的变量，事件，方法以及和其他对象的关系来描绘对象。规范的第三部分详细介绍了对象模型。</p><p> OPC UA对象模型允许服务器为对象提供类型定义和对象组件。类型定义可以被继承，也可以标准化或是由系统指定。对象类型可以由OPC基金会，其他权威组织，生产商或最终用户来定义。</p><p>统一对象模型允许把数据访问，事件报警，和历史数据访问功能集成到一个单一的OPC UA服务器中。例如，OPC UA服务器可以把一个温度传感器描述成一个对象，它由温度值，报警参数和相应的报警上下限组成。</p><p>2.3.4 统一的服务</p><p>OPC UA客户端和服务器之间的接口被定义成了一系列服务。这些服务又被组织划分成不同的组，每个组叫做服务子集。第四节对服务集进行了讨论，规范的第四部分详细说明了服务集。</p><p>OPC UA服务向客户提供两种功能服务。首先，它们允许客户端向服务器发送请求并接受服务器的相应消息。而且，它们也允许客户端向服务器订阅通知。服务器用通知来发布某些事件的发生，如报警，数据值的改变，事件以及程序执行结果。</p><p> 为了提高传输性能，OPC UA消息可以被编码生XML文本格式或是二进制格式。它们可以使用多种传输协议进行传输，例如：TCP或是通过HTTP的网络服务。规范的第七部分介绍了不同的编码和传输机制。</p><p>2.4 会话</p><p> OPC UA需要一个状态模型。状态信息被保存在应用程序会话之中。例如，状态信息可能包括订阅信息，用户认证书和跨越多重请求操作的延长点信息。</p><p>会话就是客户端和服务器之间的合法连接。服务器可以根据有效资源，许可限制或其他约束条件来限制并发的会话的数量。每个会话是不依赖底层通信协议的。通信协议的失败不会自动终止会话。会话的终止依靠客户端或服务器的指令，或客户端的失效。在会话建立时，要设定会话的间隔时间。</p><p>2.5 冗余</p><p> OPC UA的机制确保了开发商可以用同一种方式开发冗余客户端和服务器。冗余可用于提高系统的稳定性，容错性和负载平衡能力。规范的第四部分介绍了冗余的细节。规范的子协议中要求冗余支持，但是基本协议不需要冗余支持。</p><p> 【3. OPC UA 系统概要】</p><p>3.1 总貌</p><p>OPC UA系统结构以相互联系对象的方式模型化了OPC UA客户端和服务器。每个系统可能包含多个客户端和服务器。每个客户端可能同时与一个或多个服务器相连接，每个服务器也可能同时与一个或多个客户端相连接。一个应用程序可能同时包含了服务器和客户端的两部分组件，以此来达到与其他服务器和客户端的连接要求，3.3.6节描述了这种情况。</p><p>3.2 OPC UA客户端</p><p>OPC UA客户端结构模型化了C/S结构中的客户端部分。</p><p>客户端应用程序的代码实现了客户端的功能。客户端应用程序使用OPC UA客户端的API来向OPC UA服务器发送和接收相关服务的请求和响应。第四节介绍了OPC UA的服务，规范的第四部分详细说明了OPC UA的服务。</p><p>注意到“OPC UA客户端API”是一个内部接口，它把客户端应用程序代码从OPC UA通信堆栈中分离出来了。OPC UA通信堆栈把OPC UA客户端的API调用转换成消息，并通过底层消息体发送给服务器，通知服务器客户端应用程序的请求。OPC UA通信堆栈也接受来自服务器的响应和通知消息，并通过OPC UA客户端API传递给客户端应用程序。</p><p>3.3 OPC UA服务器</p><p>OPC UA服务器结构模型化了C/S结构中的服务器部分。</p><p>3.3.1 真实对象</p><p>真实对象是可以由OPC UA服务器应用程序直接访问的物理设备或包含在其内部的软件程序。</p><p>3.3.2 OPC UA服务器应用程序</p><p>OPC UA服务器应用程序的代码实现了服务器的功能。服务器应用程序使用OPC UA服务器的API来向OPC UA客户端发送和接收消息。注意到“OPC UA服务器API”是一个内部接口，它把服务器应用程序代码从OPC UA通信堆栈中分离出来了。这可能是OPC基金会提供的一个标准应用或是由生产商制定的应用。</p><p>3.3.3 OPC UA地址空间<br>3.3.3.1 地址空间节点</p><p>地址空间由一系列节点组成，客户端可以通过使用OPC UA服务（接口和方法）来访问节点。地址空间中的节点用来代表真实对象，以及它们的定义和相互之间的引用。</p><p>3.3.3.2 地址空间组织</p><p>规范的第三部分讲述了用“积木”模型以一种标准的一致的方式构造空节点地址空间的细节。服务器可以在它们的地址空间中自由的组织它们选择的节点。节点间引用的使用，允许服务器可以把地址空间组织成分层结构，网状节点结构，或任何可能的结构混合。</p><p>规范的第五部分定义了OPC UA节点，引用以及它们在地址空间中组织结构的标准。</p><p>3.3.3.3 地址空间概要<br>视点是地址空间的子集。视点限制了服务器向客户端暴露的节点数量，也就限制了客户端所能请求到的地址空间尺寸。视点的默认设置是整个地址空间。服务器可以有选择的定义其他视点。视点也就隐藏地址空间中的某些节点和引用。通过地址空间视点是可见的，客户端可以通过浏览视点从而确定它们的结构。视点通常是分层结构的，这样利于客户用树形结构来理解和表示它。</p><p>3.3.3.4 对信息模型的支持<br>OPC UA地址空间支持信息模型。支持如下：a)节点引用允许地址空间中的对象相互关联；b)对象类型节点为真实对象提供语义信息（类型定义）；c)对象类型节点支持类型定义子集；d)地址空间中暴露的数据类型定义允许使用工业上特定的数据类型；e)OPC UA的联合标准允许工业团体在OPC UA服务器的地址空间中制定它们特定信息模型的表示方法。</p><p>3.3.4.1 监控项<br>监控项是由客户端在服务器中创建的实体，它用来监控地址空间中的节点和它们现实世界中所对应的实体。当监控项检测到数据变化或有事件或报警发生时，它们就产生通知，由订阅传送给客户端。</p><p>3.3.4.2 订阅<br>订阅是服务器中的一个终端，它用来向客户端发布通知。它是客户端控制发布的条件。</p><p>3.3.5 OPC UA服务接口<br>3.3.5.1 概要<br>第四节对OPC UA定义的服务进行了介绍，规范的第四部分对它们进行了详细说明。<br>3.3.5.2 请求/响应服务<br>请求或响应服务是由客户端通过OPC UA服务接口调用的服务，它们对地址空间中的节点进行特定的操作并返回操作结果。<br>3.3.5.3 发布服务<br>发布服务是由客户端通过OPC UA服务接口调用的服务，它的作用是周期性地向客户端发送通知。通知都包括事件，报警，数据变化以及程序输出结果。<br>3.3.6 服务器之间的关联<br>服务器之间的关联就是一个服务器作为另一个服务器的客户端。服务器之间的关联考虑到了服务器的以下拓展能力：a)相互间以点对点的形式交换信息，这使得一个服务器可以连接一个冗余服务器或是一个远程服务器，用它们来保存系统额外的类型定义；b)以分层结构链接起来的服务器可以提供如下功能：1)集合底层服务器的数据；2)上层数据发往客户端；3)客户端的接口层为每个底层服务器提供单一访问结点。</p><p>【4. OPC UA 服务设置】</p><p>4.1 概要</p><p> OPC UA服务被划分成不同的服务子集，每个子集定义了一组逻辑上相关的服务，用于显示服务器一个特定的方面。以下介绍了服务子集。规范的第四部分详细说明了服务子集和它们所包含的服务。无论一个服务器是否支持一个服务子集，服务子集中的特定服务都被服务器的协议所定义。规范的第七部分介绍了协议。</p><p>4.2 安全通道服务集</p><p>这个服务子集定义的服务用作去查询一个服务器的安全配置并且构造一个通信通道，这个通道可以确保与服务器交换的所有消息是保密的，完整的。规范的第二部分定义了UA安全性的基本概念。</p><p>安全通道服务与其他服务不同，因为安全通道服务不被UA应用程序直接执行。它们是由UA应用程序所依靠的通信堆栈来提供的。例如，一个UA服务器可能被建立在一个简单对象访问协议堆栈上，这个协议堆栈允许应用程序使用网络服务安全会话规范建立安全通道。在这些情况下，当UA应用程序接收到消息时，它仅需要校验网络服务安全会话是可用的。规范的第六部分描述了安全通道服务如何被使用。</p><p>安全通道是单一客户端和单一服务器之间一个长期运行的合法连接。通道内保存了许多只有客户端和服务器知道的密钥，这些密钥用于认证和编码在网络间传输的消息。安全通道服务允许客户端和服务器安全协商密钥的使用方法。</p><p>服务器的安全策略描述了鉴定和加密消息的确切算法。一个客户端在构造一个安全通道时，必须选择一种服务器所支持的安全策略。</p><p>当一个客户端和服务器通过安全通道进行通信时，它们必须核实所有正在传入的消息已经依照某种安全策略进行了标识和加密。一个UA应用程序不能处理通道内不符合安全策略的消息。</p><p>安全通道与UA应用程序会话是相分离的，然而，一个UA应用程序会话只能通过唯一的安全通道进行访问。这说明了UA应用程序必须能够决定每条消息所联系的安全通道。通信堆栈提供了安全通道机制，但它不允许应用程序知道用于给定消息的安全通道，是不能用于完成安全通道服务的。</p><p>UA应用程序用通信堆栈去交换消息。首先，用安全通道服务在通信堆栈间构造一个安全通道，使得通信堆栈之间可以安全交换消息。然后，UA应用程序使用会话服务子集构造一个UA应用程序会话。</p><p>当一个客户端构造一个安全通道时，它可能提供一个用户标识。这个标识可能与客户端初始化UA应用程序会话时所提供的用户标识不一样。</p><p>4.3 会话服务集</p><p>这个服务集定义的服务用作去构造一个应用层的连接，这个连接就是为了一个特定用户而建立的会话。</p><p>4.4 节点管理服务集</p><p>节点管理服务集允许客户去添加，修改以及删除地址空间里的节点。这些服务为服务器的构造提供了一个标准接口。</p><p>4.5 视点服务集</p><p>视点是由服务器创造的地址空间子集。视点的默认值是全部地址空间。因此，视点服务可以操作整个地址空间。规范的未来版本可能会制定相应服务来构造客户端定义的视点。</p><p>视点服务允许客户端通过浏览视点查找节点。客户端在视点中进行分层查找，或通过节点间的引用进行查找。在这种方式下，也允许客户端查看视点的结构。</p><p>4.6 属性服务集</p><p>属性服务集用作去读写属性值。属性是由OPC UA定义的节点原始特性。它们可能不是由客户端和服务器来定义的。属性是地址空间中允许存放数据值的唯一元素。一个特定的属性，属性值用来定义变量的值。</p><p>4.7 方法服务集</p><p>方法代表了对象的函数调用。规范的第三部分定义了方法服务。方法被调用，无论成功与否，都在方法执行完毕后返回。不同方法的运行时间可能不同，这主要取决于它们运行的函数。</p><p>方法服务集定义了调用方法的手段。一个方法必须是一个对象的组件。方法的暴露由浏览和查询服务来提供。客户端查询一个服务器所支持的方法是通过浏览特有的对象来完成的，这些对象标识了自己所支持的方法。</p><p>因为方法可以控制设备操作的某些环节，所以方法调用可能依靠环境条件或其他条件。这使得反复调用同一种方法成为可能。需要调用方法的条件可能先前并没有返回一个允许该方法重新启动的状态。另外，有些方法可能支持并发调用，而有些方法只能单独调用。</p><p>4.8 监视项服务集</p><p>监视项服务集被客户端用来去构造和保存监视项。监视项用来监视变量，属性和事件通知器。当它们检测到特定条件发生时，它们会产生相应通知。监视项监视变量数值，状态或时间戳的变化；属性值的变化；以及事件通知器对新产生的报警和事件的报告。</p><p>每个监视项都标识了要监视的项目和用于向客户端周期性发布通知的订阅（参阅4.9节）。每个监视项也指定了被监视项目的采集频率，对于变量和事件通知器，用过滤标准来决定什么时候来产生通知。属性的过滤标准由规范第四部分的属性定义来加以说明。</p><p>监视项的采样速度可能比订阅的发布速度更快。所以，监视项可能由一个包含所有通知的队列组成，或是由一个仅含有最近通知的队列组成。第二种情况，队列里只含有一个通知。</p><p>监视项服务也定义了一个监视模式。这个模式可以配置成三种模式：不采集不报告模式，仅采集模式，或是既采集也报告模式。当设置了采集模式时，服务器采集被监视项的值（或状态）。另外，通过对采集结果的判断来决定是否产生一个通知。如果需要产生通知，则构建一个通知队列。如果允许报告，则通知队列可以由订阅来向外发送。</p><p>最后，一个监视项的报告选项能够由其他监视项来设置。在这种情况下，需要报告的监视项的监视模式仅需要再设置采集选项就可以了，当被触发的监视项产生一个通知时，需要报告的监视项通知队列由订阅来向外发送。</p><p>4.9 订阅服务集</p><p> 订阅服务集由客户端构造并保持和使用。订阅周期性的发布来自它们相关监视项的通知消息（参阅4.7节）。所有通知都应包含一个公共消息头。通知的格式与被监视项目的类型有关。（例如：变量，属性，和事件通知器）。</p><p>已构造出的存在的订阅并不依靠客户端与服务器的会话。这就允许由一个客户端来构造订阅，另一个客户端，可能是冗余客户端，从订阅上来接受通知消息。</p><p>有些客户端并不需要订阅，所以订阅设置了一个由客户端周期性更新的生命周期属性。如果客户端没有成功更新订阅的生命周期，则订阅终止，服务器关闭订阅。当一个订阅被关闭后，所有与它关联的监视项都被删除。</p><p>订阅也包括支持检测和恢复丢失消息的特性。每个通知消息都包含一个允许客户端检测丢失消息的序号。当没有通知在有效时间间隔内需要发送时，服务器发送一个保持消息，它含有最后一次被传送消息的序号。如果客户端在通信时间间隔终止之后还没有收到消息，它可以要求服务器重发先前消息。</p><p>4.10 查询服务集</p><p>查询服务集允许客户端选择地址空间中的一个节点子集或是一个视点中的节点子集，视点建立在客户端提供的过滤标准的基础上。被查询服务选择的节点和属性叫做一个结果集。结果集可能是节点的简单组合，其中也可能包含了节点间引用的结构。</p><p> 服务器可能发现有些查询不好处理，如查询诸如设备数据一样的实时数据，或是查询操作需要消耗大量资源或存在较长延时。这些情况下，服务器可以拒绝查询。</p><pre><code>----To Be Continued----</code></pre>]]></content>
      
      <categories>
          
          <category> introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CC-Link通信协议</title>
      <link href="/2018/05/16/introduction/intro-ccl/"/>
      <url>/2018/05/16/introduction/intro-ccl/</url>
      <content type="html"><![CDATA[<p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> industrial network </tag>
            
            <tag> field bus </tag>
            
            <tag> protocol </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CIP通信协议及其衍生</title>
      <link href="/2018/05/16/introduction/intro-cip/"/>
      <url>/2018/05/16/introduction/intro-cip/</url>
      <content type="html"><![CDATA[<p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> industrial network </tag>
            
            <tag> field bus </tag>
            
            <tag> protocol </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>USS通用串行接口协议</title>
      <link href="/2018/05/14/introduction/intro-uss/"/>
      <url>/2018/05/14/introduction/intro-uss/</url>
      <content type="html"><![CDATA[<p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protocol </tag>
            
            <tag> USS </tag>
            
            <tag> serial communication </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CRC循环冗余校验码</title>
      <link href="/2018/05/14/knowledge/know-crc/"/>
      <url>/2018/05/14/knowledge/know-crc/</url>
      <content type="html"><![CDATA[<p><strong>循环码</strong>(Cyclic Redundancy Check, CRC)是一种检错率高、编码效率高的检错码，通过除法运算来建立有效信息位和校验位之间的约定关系。<br><a id="more"></a><br>CRC码由两部分组成，前部分是<strong>信息码</strong>，后部分是<strong>校验码</strong>，若CRC码总共长$n$位，信息码长$k$位，则称为<strong>$(n,k)$码</strong>，$r=n-k$即冗余位长度，也就是校验码长度。</p><p>基本概念：</p><ul><li>$n$位二进制码可以表示最高次幂为$n-1$的多项式。</li><li><strong>按位除</strong>（模2除）运算实际上就是在除的过程中做异或运算，同时不考虑进位，直到余数的位数小于除数时得到最终余数。在异或运算中模2减与模2加真值表完全相同。</li></ul><p>对于一个给定的$(n,k)$码，可以证明存在最高次幂为$r$的<strong>生成多项式</strong>$G(x)$，满足</p><ol><li>最高位和最低位为1</li><li>当被传送信息任何一位发生错误时，被生成多项式做模2除后使余数不为0</li><li>不同位发生错误时使余数不同</li><li>对余数继续做模2除应使余数循环</li></ol><p>将这些条件反映为数学关系是复杂的，常用的对应不同码制的生成多项式$G(x)$详见<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener">Wikipedia</a>：</p><ul><li>CRC1:  $x^1+x^0$</li><li>CRC4:  $x^4+x^1+x^0$</li><li>CRC8:  $x^8+x^5+x^4+x^0$</li><li>CRC12: $x^{12}+x^{11}+x^3+x^2+x^0$</li><li>CRC16: $x^{16}+x^{15}+x^2+x^0$</li></ul><p>具体<strong>编码规则</strong>如下。</p><ol><li>接收方和发送方约定发送组的信息位k和冗余位r个数，选定生成多项式$G(x)$满足上述条件</li><li>发送方将原始数据左移$r$位得到$M(x)$，随后按位除生成多项式$G(x)$，得到余数$R(x)$，有$\frac{M(x)}{G(x)}=Q(x)…R(x)$</li><li>发送方将$M(x)$与$R(x)$连接（等同于模2加或模2减）后一起发送</li><li>接收方将收到的数据按位除生成多项式$G(x)$，若余数为$0$则传输正确，若余数不为$0$则传输错误，即$\frac{M(x)+R(x)}{G(x)}=\frac{M(x)-R(x)}{G(x)}=Q(x)…0$</li></ol><p>CRC校验码可以检查出全部单个错、全部离散二位错、全部奇数个数、全部长度小等于$k$位的突发错，并以$1-(1/2)^{k-1}$概率检查出长度位$k+1$位的突发错。</p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> communication basis </tag>
            
            <tag> error-detecting code </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络通信传输介质</title>
      <link href="/2018/05/14/knowledge/know-networkmedia/"/>
      <url>/2018/05/14/knowledge/know-networkmedia/</url>
      <content type="html"><![CDATA[<p>网络通信中常用的传输介质包括有线、无线两大类。本篇简要整理了有线传输介质、速率和网线类型、光纤类型等，以及无线传输介质等基础知识。其中以太网传输介质主要有同轴电缆、双绞线和光纤三种。无线传输介质包括无线电、红外线、激光等。<br><a id="more"></a><br>以太网传输标准IEEE 802.3标准规定了以下几种：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">传输介质</th><th style="text-align:center">传输距离</th><th style="text-align:center">连接器</th></tr></thead><tbody><tr><td style="text-align:center">10Base-5</td><td style="text-align:center">RG-8/RG-11同轴电缆（粗缆）</td><td style="text-align:center">500米</td><td style="text-align:center">AUI或MAU连接器</td></tr><tr><td style="text-align:center">10Base-2</td><td style="text-align:center">RG-58同轴电缆（细缆）</td><td style="text-align:center">185米</td><td style="text-align:center">BNC连接器</td></tr><tr><td style="text-align:center"><strong>10Base-T</strong></td><td style="text-align:center">CAT3非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">10Base-F</td><td style="text-align:center">光纤</td><td style="text-align:center">500米以上</td><td style="text-align:center">FP/FL/FB连接器</td></tr><tr><td style="text-align:center"><strong>100Base-TX</strong></td><td style="text-align:center">CAT5非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">100Base-T4</td><td style="text-align:center">CAT3非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">100Base-F</td><td style="text-align:center">光纤</td><td style="text-align:center">2000米</td><td style="text-align:center">SC</td></tr><tr><td style="text-align:center"><strong>1000Base-T</strong></td><td style="text-align:center">CAT5e非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center"><strong>1000Base-TX</strong></td><td style="text-align:center">CAT6非屏蔽双绞线</td><td style="text-align:center">100米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">1000Base-CX</td><td style="text-align:center">屏蔽双绞线</td><td style="text-align:center">25米</td><td style="text-align:center">RJ45连接器</td></tr><tr><td style="text-align:center">1000Base-LX</td><td style="text-align:center">单模光纤</td><td style="text-align:center">3000米</td><td style="text-align:center">SFP</td></tr><tr><td style="text-align:center">1000Base-SX</td><td style="text-align:center">多模光纤</td><td style="text-align:center">300-550米</td></tr></tbody></table><p>其中数字表示网络数据传输速率，单位为Mbps；Base表示基带传输，即未经过调制、不能复用的传输，Broad表示宽带传输；-后面的字母或数字指传输介质。</p><p><strong>同轴电缆</strong>是指导体和屏蔽层共用同一轴心的电缆。同轴电缆由里到外分为四层：中心铜线，塑料绝缘体，网状导电层（屏蔽层）和外层保护套，中心铜线和网状导电层形成电流回路。<br><strong>基带同轴电缆</strong>特征阻抗为50Ω，如RG-8、RG-58等，传输基带数字信号。<br><strong>宽带同轴电缆</strong>特征阻抗为75Ω，如RG-59等，传输频分多路模拟信号。</p><p><strong>双绞线</strong>把两根22-26号绝缘铜导线按一定密度互相绞在一起，每一根导线在传输中辐射出来的电波会被另一根线上发出的电波抵消，有效降低信号干扰的程度。与其他传输介质相比，双绞线在传输距离，信道宽度和数据传输速度等方面均受到一定限制，但价格较为低廉，应用非常广泛。<br><strong>屏蔽双绞线</strong>在双绞线与外层绝缘封套之间有一个金属屏蔽层。<strong>STP</strong>(Shielded Twisted Pair)指每条线都有各自的屏蔽层，而<strong>FTP</strong>(Foil Twisted Pair)只在整个电缆有屏蔽装置，并且两端都正确接地时才起作用。屏蔽层可减少辐射，防止信息被窃听，也可阻止外部电磁干扰，屏蔽双绞线比同类的非屏蔽双绞线具有更高的传输速率。<br><strong>非屏蔽双绞线UTP</strong>(Unshielded Twisted Pair)直径小、成本低、易弯曲、易安装，广泛用于以太网和电话线中。常见的非屏蔽双绞线由4对8根不同颜色的传输线组成。<br><img src="/2018/05/14/knowledge/know-networkmedia/twisted_pair.jpg" alt="twisted pair"><br>按照频率带宽和信噪比双绞线可以分为：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">最高频率带宽</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:center">CAT1</td><td style="text-align:center">750kHz</td><td style="text-align:left">用于报警系统，不用于数据传输</td></tr><tr><td style="text-align:center">CAT2</td><td style="text-align:center">1MHz</td><td style="text-align:left">用于语音传输和最高4Mbps的数据传输</td></tr><tr><td style="text-align:center">CAT3</td><td style="text-align:center">16MHz</td><td style="text-align:left">用于10Base-T以太网和4Mbps令牌环</td></tr><tr><td style="text-align:center">CAT4</td><td style="text-align:center">20MHz</td><td style="text-align:left">用于局域10Base-T/100Base-T以太网和16Mbps令牌环</td></tr><tr><td style="text-align:center"><strong>CAT5</strong></td><td style="text-align:center">100MHz</td><td style="text-align:left">用于10Base-T/100Base-T网络</td></tr><tr><td style="text-align:center">CAT5e</td><td style="text-align:center">100MHz</td><td style="text-align:left">用于1000Base-T网络</td></tr><tr><td style="text-align:center">CAT6</td><td style="text-align:center">250MHz</td><td style="text-align:left">用于最高1Gbps的数据传输</td></tr><tr><td style="text-align:center">CAT6A</td><td style="text-align:center">500MHz</td><td style="text-align:left">用于最高10Gbps的数据传输</td></tr><tr><td style="text-align:center">CAT7</td><td style="text-align:center">600MHz</td><td style="text-align:left">用于最高10Gbps的数据传输</td></tr></tbody></table><p>目前最常用的为CAT5和CAT6，CAT6以上的产品国家未出台正式检测标准。电话线接口常用RJ11连接器，网线接口常用RJ45连接器，都称为水晶头。</p><p>EIA/TIA标准规定了两种双绞线线序T568A和T568B，常用网线分为<strong>直连互联</strong>和<strong>交叉互联</strong>两种接法。<br>可以看作<strong>数据终端设备</strong>(Data Terminal Equipment, DTE)的有电脑、路由器、交换机uplink口、HUB级联口等，可以看<strong>数据电路终接设备</strong>(Data Circuit-terminating Equipment, DCE)的有交换机普通口、HUB普通口等。同类设备间相连使用交叉线方式，异类设备间相连使用直通线方式。现在的交换机通常具有端口自动翻转功能，因此对直通线和交叉线不加以区分。<br><img src="/2018/05/14/knowledge/know-networkmedia/utp&amp;stp.jpg" alt="twisted pair"></p><p><strong>光纤</strong>由光导纤维作为芯线加上防护外皮做成的，通常采用石英玻璃拉成的细丝，通过光信号进行传输。光纤只能做单向传输，通过成对使用进行双向通信。相比于其他介质，光纤具有传输距离长、速率高、抗干扰能力强、延时小等特点，主要使用于大型网络主干线。<br><strong>单模光纤</strong>中心的玻璃芯很细，只能传播一种模式的光信号，在单模光纤中光沿直线传播，无反射，传播距离非常远，一般为黄色。<br><strong>多模光纤</strong>芯径较大，可以传输多种模式的光信号，一般为橘红色或灰色，不同模光进入光纤的角度不同，它们到达另一端的时间也不同，称为<strong>模分散</strong>，模分散技术限制了多模光纤的带宽和距离。<br><img src="/2018/05/14/knowledge/know-networkmedia/optical_fiber.JPG" alt="twisted pair"></p><p>常见的光纤接口包括SC（方形卡接式）、LC（圆形小）、DLC（圆形小双头）、FC（圆形带螺纹）、ST（圆形卡接式）和MTRJ（方形双头）等，插芯研磨平面又可以分为PC、UPC、APC等。<br><strong>光电转换器</strong>又称光纤收发器，是一种将短距离电信号和长距离光信号进行互换的设备，目前最常用的光电转换器为热插拔小封装模块(Small Form-factor Pluggables, SFP)，具有体积小、端口多等优点，多采用LC接口。<strong>光纤耦合器</strong>又称分歧器，将光信号从一条光纤中分至多条光纤中。</p><p><img src="/2018/05/14/knowledge/know-networkmedia/spectrum.jpg" alt="spectrum"></p><p>在自由空间传播的电磁波或广播统称为无线传输介质。<br><strong>无线电波</strong>指1GHz以内的电磁波，通信常用600MHz~1GHz频段，该频段信号会穿透电离层，传播损耗较大，一般用于沿地面局部无方向性广播通信场合。我国的调频广播为88-108MHz。<br><strong>微波</strong>指1~300GHz范围内的电磁波，常用2~30GHz频段，该频段微波沿直线传播，同时会穿透电离层进入宇宙空间，一般用于地面微波接力通信或卫星通信。<br><strong>红外线</strong>具有很强的方向性，但对环境干扰敏感。通信链路只需要一对收发器，设备便宜且不需要天线，一般用于室内通信、近距离遥控等。<br><strong>激光通信</strong>具有通信容量大、保密性强、结构轻便等优点，同时具有通信距离短、易受干扰、瞄准困难等缺点，一般用于地面短距离通信和星际通信等。</p><p>Wifi是一种民用无线电磁波技术，工作在2.4GHz、5GHz、60GHz这几个国家允许的频段下。蓝牙和无线键鼠等也工作在2.4GHz。我国手机数据通信主要集中在1.8GHz、2.1GHz、2.3GHz、2.6GHz等频段。</p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network basis </tag>
            
            <tag> transmission media </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工业设备通信协议概览</title>
      <link href="/2018/05/10/review/rev-industrialnet/"/>
      <url>/2018/05/10/review/rev-industrialnet/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/10/review/rev-industrialnet/protocols.jpg" alt="protocols"><br>本篇介绍了常见的工业现场总线和工业以太网协议。<br><a id="more"></a></p><p>工业以太网、现场总线、工业无线是目前工业通信领域的三大主流技术。</p><p>IEC 61158于2007年第四版标准规定了20种类型的通信协议：<br><img src="/2018/05/10/review/rev-industrialnet/IEC.JPG" alt="IEC">其中Type1可以理解为FF现场总线，Type2包括DeviceNet、ControlNet和EtherNet/IP，Type6由于应用不理想被撤销。</p><p>常见工业现场总线一览：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">推出时间</th><th style="text-align:center">主推公司</th><th>特点</th><th>链接</th></tr></thead><tbody><tr><td style="text-align:center">ASi (AS-Interface)</td><td style="text-align:center"></td><td style="text-align:center"></td><td>$1</td><td></td></tr><tr><td style="text-align:center">CAN</td><td style="text-align:center">1986</td><td style="text-align:center">博世</td><td></td><td></td></tr><tr><td style="text-align:center">CC-Link</td><td style="text-align:center">1996</td><td style="text-align:center">三菱</td><td></td><td></td></tr><tr><td style="text-align:center">CompoNet</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">ControlNet</td><td style="text-align:center">1997</td><td style="text-align:center">罗克韦尔</td><td></td><td></td></tr><tr><td style="text-align:center">DeviceNet</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">Fipio</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">InterBus</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">LonWorks</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center"><strong>Modbus</strong></td><td style="text-align:center">1979</td><td style="text-align:center">施耐德</td><td></td><td></td></tr><tr><td style="text-align:center"><strong>Profibus</strong></td><td style="text-align:center">1986</td><td style="text-align:center">西门子</td><td></td><td></td></tr></tbody></table><p>常见工业网络协议一览：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">推出时间</th><th style="text-align:center">主推公司</th><th>特点</th><th>链接</th></tr></thead><tbody><tr><td style="text-align:center">CC-Link IE</td><td style="text-align:center">xxxx</td><td style="text-align:center">三菱</td><td></td><td></td></tr><tr><td style="text-align:center">EtherCAT</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">EtherNet/IP</td><td style="text-align:center">2000</td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center"><strong>Modbus-TCP</strong></td><td style="text-align:center">1998</td><td style="text-align:center">施耐德</td><td></td><td></td></tr><tr><td style="text-align:center"><strong>Profinet</strong></td><td style="text-align:center">2001</td><td style="text-align:center">西门子</td><td></td><td></td></tr><tr><td style="text-align:center">SERCOS Ⅲ</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><p>其他通信协议：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">推出时间</th><th style="text-align:center">主推公司</th><th>特点</th><th>链接</th></tr></thead><tbody><tr><td style="text-align:center">BACnet</td><td style="text-align:center">wangluo</td><td style="text-align:center"></td><td></td><td>$1</td></tr><tr><td style="text-align:center">GD (Global Data)</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">Ethernet TCP/IP</td><td style="text-align:center">以太网</td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">IO-Link</td><td style="text-align:center">点对点</td><td style="text-align:center"></td><td></td><td></td></tr><tr><td style="text-align:center">USS</td><td style="text-align:center"></td><td style="text-align:center">西门子</td><td></td><td></td></tr><tr><td style="text-align:center">USB</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> industrial network </tag>
            
            <tag> field bus </tag>
            
            <tag> protocol </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《数据库原理与应用》笔记</title>
      <link href="/2018/05/10/note/note-database/"/>
      <url>/2018/05/10/note/note-database/</url>
      <content type="html"><![CDATA[<p><strong>《数据库原理与应用——SQL Server 2016版本》 主编：邓立国 佟强 清华大学出版社 2017年9月第1版 TP311.138 ISBN: 978-7-302-48305-2 </strong><br>本书系统地讲述数据库原理与SQL Server 2016的功能、应用及实践知识，包括关系数据库知识、数据库创建与维护、数据库表的操作管理及维护、完整性控制、查询与管理表数据、Transaction-SQL编程、存储过程和触发器、数据库安全管理、数据库系统开发配置连接等知识。<br>笔记在该书基础上重新组织并扩展内容，旨在完整地梳理SQL Server数据库知识以供学习和查阅。<br><a id="more"></a></p><!-- toc --><ul><li><a href="#第一章-数据库基础知识">第一章 数据库基础知识</a><ul><li><a href="#11-数据库系统概论">1.1 数据库系统概论</a></li><li><a href="#12-数据模型">1.2 数据模型</a></li><li><a href="#13-数据库模式结构">1.3 数据库模式结构</a></li><li><a href="#14-数据库系统组成">1.4 数据库系统组成</a></li></ul></li><li><a href="#第二章-数据库设计">第二章 数据库设计</a></li><li><a href="#第三章-数据库编程">第三章 数据库编程</a><ul><li><a href="#31-关系数据库标准语言sql">3.1 关系数据库标准语言SQL</a></li><li><a href="#32-sql-server中的transact-sql语言">3.2 SQL Server中的Transact-SQL语言</a></li><li><a href="#33-程序设计接口odbc与jdbc">3.3 程序设计接口ODBC与JDBC</a></li></ul></li><li><a href="#第四章-认识sql-server-2016">第四章 认识SQL Server 2016</a></li><li><a href="#第五章-数据库操作">第五章 数据库操作</a><ul><li><a href="#51-数据库的操作">5.1 数据库的操作</a></li></ul></li><li><a href="#第六章-数据表操作">第六章 数据表操作</a><ul><li><a href="#61-数据类型">6.1 数据类型</a></li><li><a href="#62-操作表">6.2 操作表</a></li><li><a href="#64-表约束">6.4 表约束</a></li></ul></li><li><a href="#第七章-数据操作">第七章 数据操作</a></li><li><a href="#第八章-复杂查询">第八章 复杂查询</a><ul><li><a href="#游标">游标</a></li></ul></li><li><a href="#第九章-函数-存储过程与触发器">第九章 函数、存储过程与触发器</a><ul><li><a href="#101-存储过程">10.1 存储过程</a></li><li><a href="#102-触发器">10.2 触发器</a></li></ul></li><li><a href="#第十一章-事务-定时作业和错误日志">第十一章 事务、定时作业和错误日志</a></li><li><a href="#第十二章-数据库安全">第十二章 数据库安全</a><ul><li><a href="#104-权限管理">10.4 权限管理</a></li></ul></li></ul><!-- tocstop --><h1><span id="第一章-数据库基础知识">第一章 数据库基础知识</span></h1><h2><span id="11-数据库系统概论">1.1 数据库系统概论</span></h2><p><strong>数据</strong>(Data)是指能输入计算机并能被计算机程序处理的所有符号，是数据库中存储的基本对象。数据被赋予的含义称为数据的语义。<br><strong>数据库</strong>(DataBase, DB)是指在计算机存储设备上建立起来的用于存储数据的仓库。按照一定的数学模型组织、描述和存储数据，使得数据库中的数据具有尽可能小的冗余度、较高的独立性和易扩展性。<br><strong>数据库管理系统</strong>(DataBase Management System, DBMS)是指位于用户和操作系统之间的数据管理软件，实现数据和数据库的管理和操作。<br><strong>数据库系统</strong>(DataBase System, DBS)是指带有数据库并利用数据库技术管理数据的计算机系统，一般由满足一定要求的计算机硬件和包括数据库、数据库管理系统、数据库应用开发系统在内的计算机软件，以及相关人员组成。</p><p>对数据的管理经理了人工管理、文件系统管理和数据库管理三个主要阶段，数据库管理的主要优势为：数据结构化、数据共享性和独立性高、冗余度低、易扩充。</p><h2><span id="12-数据模型">1.2 数据模型</span></h2><p><strong>数据模型</strong>是对现实世界进行模拟与抽象，是一组概念的集合，是数据库系统的核心和基础。</p><p>数据模型通常由数据结构、数据操作和完整性约束三个部分组成。<br><strong>数据结构</strong>是数据对象的集合，描述了数据对象的类型、内容、属性及数据对象之间的关系，是对系统静态特性的描述。<strong>数据操作</strong>是允许执行操作的集合，是对系统动态特性的描述。<strong>数据完整性约束</strong>是规则的集合，是对数据之间制约和依存关系的描述，用于保证数据的完整性和一致性。</p><p>数据模型分为概念模型、逻辑模型和物理模型三个抽象层级。<br><strong>概念模型</strong>是现实世界到信息世界的抽象，用符号记录现实世界的信息，与具体的计算机系统无关。基本概念有实体（客观存在并可相互区别的事务）、属性（实体所具有的某一特性）、码（唯一标识实体的属性集合）、域（属性的取值范围）、实体型（同类实体的共同属性）、实体集（同类实体的集合）、联系（包括实体型内部各个属性的联系和实体型之间的联系）。两个实体型之间的联系可以分为一对一、一对多、多对多三种。概念模型最常用的表示方法是<strong>实体-联系图</strong>(Entity-Relationship Graph, E-R图)，矩形表示实体型，椭圆表示属性，无向边和菱形表示联系并标注联系类型。<br><strong>逻辑模型</strong>是信息世界到计算机世界的抽象，不同的逻辑模型与DBMS有关。<br>目前比较成熟的逻辑模型有层次模型、网状模型和关系模型，层次模型以树结构表示数据之间的关联；网状模型以图结构表示数据之间的关联；关系模型以二维表表示数据之间的关联，概念单一、结构简单，建立在严格的数学概念基础上，是目前最重要、应用最广泛的逻辑模型。<br><strong>物理模型</strong>是逻辑模型在计算机中的存储结构，包含数据的存储和数据之间联系的存储。</p><h2><span id="13-数据库模式结构">1.3 数据库模式结构</span></h2><p>数据库系统通常采用三级模式和二级映象的系统结构，并以此保证了数据较高的逻辑独立性和物理独立性。<strong>三级模式结构</strong>是指外模式、模式和内模式，<strong>二级映象</strong>是指外模式/模式和模式/内模式的映象。<br><strong>外模式</strong>也称子模型或用户模式，是数据库用户的数据视图，是与某一应用有关的数据逻辑表示，应用程序开发依赖于数据的外模式。<br><strong>模式</strong>也称逻辑模式或概念模式，是数据库设计者用某种数据模型对全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图。<br><strong>内模式</strong>也称物理模式或存储模式，描述了数据在存储介质上的存储方式和物理结构，一个数据库只有一个内模式，内模式由内模式描述语言来定义。<br><strong>外模式/模式映象</strong>实现了数据的逻辑独立性，即当数据的逻辑结构改变时，只需要改变相应的外模式/模式映象，不需要改变用户程序。对于每个外模式，数据库都有一个外模式/模式映象。<br><strong>模式/内模式映象</strong>实现了数据的物理独立性，当数据的存储结构发生变化时，只需要数据库管理员改变相应的模式/内模式映象，不需要改变模式。数据库的模式/内模式映象是唯一的。</p><h2><span id="14-数据库系统组成">1.4 数据库系统组成</span></h2><p>数据库系统包括计算机硬件、计算机软件和人员。<br>数据库系统中的人员主要分为四类：<br><strong>数据库系统和数据库设计人员</strong>，前者负责应用系统需求分析和规范说明、确定系统硬件配置、参与数据库系统概要设计，后者负责数据库中数据的确定和各级模式的设计。<br><strong>应用程序员</strong>负责编写使用数据库的应用程序，应用程序可以对数据进行检索、建立、删除或修改。<br><strong>最终用户</strong>利用系统的接口或查询语言范围数据库。<br><strong>数据库管理员</strong>(Database Administrator, DBA)负责数据库的总体信息控制，即决定信息内容和结构、决定存储结构和存取策略、定义安全性要求和完整性约束条件、监控运行情况、改进性能等。<br><img src="/2018/05/10/note/note-database/user_model.jpg" alt="user_model"></p><h1><span id="第二章-数据库设计">第二章 数据库设计</span></h1><h1><span id="第三章-数据库编程">第三章 数据库编程</span></h1><h2><span id="31-关系数据库标准语言sql">3.1 关系数据库标准语言SQL</span></h2><p><strong>结构化查询语言（Structured Query Language, SQL）</strong>是关系数据库的标准语言，具有集数据查询、数据操作、数据定义和数据控制于一体的强大功能，通过九个动词来实现：SELECT、CREATE、DROP、ALTER、INSERT、UPDATE、DELETE、GRANT、REVOKE。</p><!-- | SQL功能 | 动词 || :-----: | :--- || 数据查询 | SELECT || 数据定义 | CREATE、DROP、ALTER || 数据操纵 | INSERT、UPDATE、DELETE || 数据控制 | GRANT、REVOKE | --><p>支持SQL的RDBMS同样支持关系数据库二级模式结构，外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件的逻辑结构，其物理结构是任意的，对用户是透明的。各个RDBMS产品在实现标准SQL时有所差别。</p><h2><span id="32-sql-server中的transact-sql语言">3.2 SQL Server中的Transact-SQL语言</span></h2><p><strong>Transact-SQL</strong>是Microsoft SQL Server中对SQL-3标准的实现和扩展，具有SQL的主要特点，同时增加了多种语言元素，使其功能更加强大。<br>根据其具体完成的功能，可以将Transact-SQL语句分为四大类：</p><ol><li>数据定义语句：CREATE、DROP、ALTER等</li><li>数据操纵语句：SELECT、INSERT、DELETE、UPDATE等</li><li>数据控制语句：GRANT、DENY、REVOKE等</li><li>附加的语言元素：BEGIN/END、COMMIT、ROLLBACK、DECLARE、SET、FETCH、CLOSE、EXECUTE等</li></ol><p>数据库对象的名称即为<strong>标识符</strong>，对象标识符实在定义对象时创建的，之后用于引用该对象，但有些对象标识符是不可选的。按照标识符的使用方式可以分为两类，即常规标识符和分隔标识符，包含的字符数必须在1~128之间。<br><strong>常规标识符</strong>的格式规则取决于数据库兼容级别，当兼容级别为100时，适用下列规则：</p><ul><li>第一个字符必须是Unicode3.2所定义的字符，包括a-z、A-Z、其他语言的字符、_@#等。</li><li>后续字符可以包括Unicode3.2所定义的字符、数字、_@#$等</li><li>不能为Transact-SQL的保留字（大小写不区分）</li><li>不能嵌入空格、不能使用增补字符</li></ul><p><strong>分隔标识符</strong>是包含在双引号””或方括号[]内的标识符，符合标识符格式规则的可以分隔也可以不分隔，若包含保留字或使用了特殊字符，必须进行分隔。<br>在搜索数据库中的对象时，<strong>通配符</strong>包括：%（任意字符串）、_（任意字符）、[]集合中的字符、[^]不属于集合中的字符。</p><p><strong>常量</strong>表示特定数据值。ASCII字符串常量用单引号，每个字符占一个字节，Unicode字符串常量在单引号前加大写N，每个字符用两个字节存储。十六进制整型常量用前缀0x表示，浮点用E表示。money常量以$为前缀；datetime常量使用特定格式字符表示；uniqueidentifier常量表示全局唯一标识符，可以指定字符格式或十六进制字符串格式。<br><strong>变量</strong>在程序运行过程中会发生改变。<strong>局部变量</strong>是用户自己定义的变量，只能保存一个值，作用范围仅在程序内部。局部变量用以下语句来声明和赋值：</p><pre><code>DECLARE {@变量名 数据类型}[...n]SET @变量名 = 值 [,...n] （普通赋值）SELECT @变量名 = 值 [,...n] （查询赋值）</code></pre><p>使用SELECT语句赋值时，若返回多个值则结果为返回的最后一个值。<br><strong>全局变量</strong>也称配置函数，用于存储系统的特性信息，作用范围不限于某一程序，在服务器级定义，以@@开头，对于用户是只读的，常用的全局变量见书P155。</p><p><strong>运算符</strong>按照起功能分类如下，优先级见书P159：</p><ol><li>算数运算符：+ - * / %</li><li>赋值运算符：=</li><li>逻辑运算符：ALL AND ANY BETWEEN EXISTS IN LIKE NOT OR SOME</li><li>位运算符：&amp; | ^ ~</li><li>比较运算符：= &gt; &lt; &gt;= &lt;= &lt;&gt; != !&lt; !&gt;</li><li>字符串串联运算符：+</li></ol><h2><span id="33-程序设计接口odbc与jdbc">3.3 程序设计接口ODBC与JDBC</span></h2><h1><span id="第四章-认识sql-server-2016">第四章 认识SQL Server 2016</span></h1><h1><span id="第五章-数据库操作">第五章 数据库操作</span></h1><h2><span id="51-数据库的操作">5.1 数据库的操作</span></h2><!-- ## 3.1 数据定义只有拥有DBA权限的用户才能调用创建模式的命令。创建和删除模式的语句：    CREATE SCHEMA [模式名] AUTHORIZATION 用户名 [SQL语句]    DROP SCHEMA 模式名 [{RESTRICT|CASCADE}]基本表的定义和删除 --><h1><span id="第六章-数据表操作">第六章 数据表操作</span></h1><p><strong>表</strong>是关系模型中表示实体的方式，是数据库存储数据的主要对象，同一数据库不能有相同表名。SQL Server中表由行和列组成，行称为<strong>记录</strong>，列称为<strong>字段</strong>，行和列的顺序都是任意的，一个表最多可以定义1024列且列名唯一。</p><p>视图和索引</p><h2><span id="61-数据类型">6.1 数据类型</span></h2><p><img src="/2018/05/10/note/note-database/data_type.jpg" alt="data_type"></p><h2><span id="62-操作表">6.2 操作表</span></h2><p><strong>创建表</strong>一般要经过定义表结构、设置约束和添加数据三个步骤。设计表结构时需要确定表的名称、表包含的各个列名、数据类型和长度、能否为空值等。</p><p>数据表可以通过图形界面创建，也可以通过SQL语句：</p><pre><code>CREATE TABLE [数据库名][所有者]表名(列名 数据类型 [{NULL|NOT NULL}] [,... n])[ON {文件组|&quot;default&quot;}]</code></pre><p><strong>删除表</strong>可以通过SQL语句：</p><pre><code>DROP TABLE 表名 [{RESTRICT|CASCADE}]</code></pre><p>使用SQL语句<strong>对表进行操作</strong>，增加、删除列和修改列属性的语句：</p><pre><code>ALTER TABLE 表名ADD 列名 数据类型 [{NULL|NOT NULL}] [,... n]DROP COLUMN 列名 [,... n]ALTER COLUMN 列名 数据类型 [{NULL|NOT NULL}] [,... n]</code></pre><p>此外，查看表的属性、重命名表、重命名列可以通过调用存储过程实现：</p><pre><code>EXEC sp_helpEXEC sp_rename &apos;旧名&apos;, &apos;新名&apos;, {&apos;TABLE&apos;|&apos;COLUMN&apos;}</code></pre><!-- ### 6.3 操作数据操作表数据同样可以通过图形界面或SQL语句实现。 --><h2><span id="64-表约束">6.4 表约束</span></h2><h1><span id="第七章-数据操作">第七章 数据操作</span></h1><h1><span id="第八章-复杂查询">第八章 复杂查询</span></h1><h2><span id="游标">游标</span></h2><p><strong>游标</strong>可以理解为一个定义在特定数据集上的指针，可以通过游标遍历数据集，或仅仅指向特定的行。在关系数据库中查询是面向集合的，而游标打破了这一规则，使操作变为逐行进行。使用游标会占用更多内存，减少可用并发，锁定资源，以及更多的代码量。</p><p>定义游标：</p><pre><code>DECLARE 游标名 CURSOR     [{LOCAL|GLOBAL}     {FORWARD_ONLY|SCROLL}     {STATIC|KEYSET|DYNAMIC|FAST_FORWORD}     {READ_ONLY|SCROLL_LOCKS|OPTIMISTIC}     TYPE_WARNING]    FOR SQL语句    [ FOR UPDATE [ OF column_name [ ,...n ] ] ]</code></pre><p>定义游标为局部游标(LOCAL)，需像定义局部变量一样在游标名前加”@”，批处理结束后被释放；定义游标为全局游标(GLOBAL)，只支持定义时直接赋值，在批处理结束后依然有效。<br>只进游标(FORWARD_ONLY)意味着游标只能从数据集开始向结束方向读取，只能用FETCH NEXT；滚动游标(SCROLL)支持游标在定义的数据集中向任何方向或位置移动。<br>STATIC意味着游标建立时会创建副本，对真实表内数据的更改不会影响到游标内容；DYNAMIC与其完全相反；KEYSET是介于前两者的折中方案，将游标所在的结果集的主键存入临时表，当结果集中行改变或删除时游标内容改变，但新加入的数据不会造成游标内容改变；FAST_FORWARD根据情况选择采用动态计划或静态计划。<br>READ_ONLY代表游标只能读取数据，不能做任何更新；SCROLL_LOCKS将读入数据进行锁定，防止其他程序更改，以确保更新成功；OPTIMISTICS不锁定任何数据，根据底层表数据更新情况来决定更新游标内数据是否成功。</p><p>打开/关闭/释放游标：</p><pre><code>{OPEN|CLOSE|DEALLOCATE} 游标名</code></pre><p>使用游标分为两部分操作，一是操作游标在数据集内的指向，二是对游标所指向行的操作。游标移动选项一共6种，分别为第一行(FIRST)、最后一行(LAST)、下一行(NEXT)、上一行(PRIOR)、直接跳到某行(ABSOLUTE(n))、相对目前跳几行(RELATIVE(n))。<br>游标经常会和全局变量@@FETCH_STATUS和WHILE循环来共同使用，以达到遍历游标所在数据集的目的。</p><p>使用游标的注意事项：</p><ol><li>尽量不要用，尤其是大量数据</li><li>尽量使用FAST_FORWARD，避免使用INSENSITIVE/STATIC/KEYSET这些参数</li><li>如果只对数据进行读取并只用到FETCH NEXT选项，最好使用FORWARD_ONLY</li><li>用完之后一定要关闭和释放</li></ol><h1><span id="第九章-函数-存储过程与触发器">第九章 函数、存储过程与触发器</span></h1><h2><span id="101-存储过程">10.1 存储过程</span></h2><p><strong>存储过程</strong>是由一系列Transact-SQL语句构成的程序，经编译后存储在数据库中，可以通过名称直接调用。存储过程还可以接受参数，提高存储过程的灵活性。在SQL Server中，存储过程的类型主要有：用户存储过程、扩展存储过程和系统存储过程。<strong>用户存储过程</strong>包括Transact-SQL存储过程和CLR存储过程；<strong>扩展存储过程</strong>可以加载外部DLL；<strong>系统存储过程</strong>用来实现数据库的管理活动，存放在master中，但其他数据库也可以调用。常用系统存储过程和分类见书P301。</p><p>创建和修改存储过程：</p><pre><code>{CREATE|ALTER} PROC[EDURE] 存储过程(组)名[;序号][{@参数名 数据类型} [=默认值] [OUTPUT]] [,... n][WITH {RECOMPILE|ENCRYPTION|RECOMPILE,ENCRYPTION}][FOR REPLICATION]AS {SQL语句 [,... n]} </code></pre><p>删除存储过程：</p><pre><code>DROP PROC[EDURE] 存储过程(组)名</code></pre><p>执行存储过程：</p><pre><code>EXEC[UTE] 存储过程(组)名[;序号][[@参数名=]参数值|@参数名 [OUTPUT]|[DEFAULT]] [,... n][WITH RECOMPILE]</code></pre><h2><span id="102-触发器">10.2 触发器</span></h2><p><strong>触发器</strong>是一种特殊的存储过程，可以看作是表定义的一部分，用于对表进行完整性约束。在SQL Server中，触发器的类型主要有：DML触发器、DDL触发器和登录触发器。</p><p>当数据库中发生数据操纵语言(DML)事件时将调用<strong>DML触发器</strong>。按照触发操作的不同可以分为INSERT触发器、UPDATE触发器和DELETE触发器，SQL Server为每个语句创建deleted表或（和）inserted表，表结构与定义触发器的表结构相同，触发器执行完成后自动删除。按照触发时间的不同可以分为AFTER(FOR)触发器和INSTEAD OF触发器。<br>当数据库中发生数据定义语言(DLL)事件时将调用<strong>DLL触发器</strong>，主要用于任务管理。DLL事件主要包括CREATE/ALTER/DROP/GRANT/DENY/REVOKE等语句操作。<br>LOGON事件激发<strong>登录触发器</strong>，将在登录身份验证阶段完成之后用户会话建立之前触发。</p><p>创建和修改DML触发器：</p><pre><code>{CREATE|ALTER} TRIGGER [模式名.]触发器名ON {表名|视图名}[WITH DML触发器选项 [,... n]]{FOR|AFTER|INSTEAD OF}{[INSERT][,][UPDATE][,][DELETE]}AS {SQL语句 [,... n]}</code></pre><p>删除DML触发器：</p><pre><code>DROP TRIGGER 触发器名 [,... n]</code></pre><p>创建和修改DLL触发器发：</p><pre><code>{CREATE|ALTER} TRIGGER 触发器名ON {DATABASE|ALL SERVER}[WITH DLL触发器选项 [,... n]]{FOR|AFTER} {触发事件名称|触发事件分组名称} [,... n]AS {SQL语句 [,... n]}</code></pre><p>其中常见的数据库作用域的DLL语句和服务器作用域的DLL语句见P315。</p><p>删除DLL触发器：</p><pre><code>DROP TRIGGER 触发器名 [,... n]ON {DATABASE|ALL SERVER}</code></pre><p>启用和禁用触发器：</p><pre><code>{ENABLE|DISABLE} TRIGGER {[模式名.]触发器名 [,... n]|ALL}ON {表名|视图名|DATABASE|ALL SERVER}</code></pre><h1><span id="第十一章-事务-定时作业和错误日志">第十一章 事务、定时作业和错误日志</span></h1><p>事务</p><h1><span id="第十二章-数据库安全">第十二章 数据库安全</span></h1><h2><span id="104-权限管理">10.4 权限管理</span></h2><p><strong>权限</strong>是执行操作、访问数据的通行证。<br><strong>预定义权限</strong>是指不必通过授予即拥有过的权限，如数据库角色所拥有的权限。<strong>未预定义权限</strong>是指经过授权或集成才能得到的权限，大多数安全主体都需要经过授权才能获取安全对象的使用权限。</p><p><strong>针对所有对象的权限</strong>包括：<br>TAKE OWNERSHIP权限，允许被授权者获得安全对象的所有权。<br>CONTROL权限，被授权者拥有对安全对象所定义的所有权限，但不具有安全对象的所有权。<br>ALTER权限，被授权者可以更改特定安全对象。<br>ALTER ANY权限，被授权者可以更改特定安全对象类型。<br>IMPERSONATE权限，被授权者模拟指定的用户执行各种操作。<br>CREATE权限，被授权者可以创建安全对象。<br>VIEW DEFINITION权限，被授权者可以查看数据库元数据。</p><p><strong>针对特定对象的权限</strong>包括：<br>SELECT（查询）权限、UPDATE（更新）权限、INSERT（插入）、DELETE（删除）权限、EXECUTE（执行）权限、REFERENCE（引用）权限。</p><p><img src="/2018/05/10/note/note-database/object_grant.jpg" alt="object_grant"></p><p>授予权限，在安全系统中创建一项使角色或用户获得权限：</p><pre><code>GRANT {ALL|权限名[,..n]} [ON 安全对象] TO 被授权者[,..n] [WITH GRANT OPTION]</code></pre><p>WITH GRANT OPTION允许被授权者将权限授予其他用户。</p><p>拒绝权限，在安全系统中创建一项禁止角色或用户获得或继承权限：</p><pre><code>DENY [GRANT OPTION FOR] {ALL|权限名[,..n]} [ON 安全对象] {TO|FROM} 被授权者[,..n] [CASCADE]</code></pre><p>GRANT OPTION FOR撤销授予指定权限的能力。CASCADE表示撤销当前主体权限的同时，还撤销当前主体为其他主体授予的权限。</p><p>收回权限，删除安全系统中授予或拒绝角色或用户的权限。</p><pre><code>REVOKE [GRANT OPTION FOR] {ALL|权限名[,..n]} [ON 安全对象] {TO|FROM} 被授权者[,..n] [CASCADE]</code></pre><p>可选参数含义同上。</p><blockquote><p>To Be Continued</p></blockquote>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> database </tag>
            
            <tag> SQL Server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Profibus和Profinet通信协议</title>
      <link href="/2018/05/04/introduction/intro-profi/"/>
      <url>/2018/05/04/introduction/intro-profi/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/04/introduction/intro-profi/logo.jpg" alt="pi-logo"></p><p><a href="https://www.profibus.com/" target="_blank" rel="noopener">https://www.profibus.com/</a></p><p><strong>Profibus(Process Field Bus，过程现场总线)</strong>是一种国际化、开放式、不依赖于设备生产商的现场总线标准</p><p><strong>Profinet(Process Field Net, )</strong></p><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> industrial network </tag>
            
            <tag> field bus </tag>
            
            <tag> protocol </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Modbus通信协议</title>
      <link href="/2018/05/03/introduction/intro-modbus/"/>
      <url>/2018/05/03/introduction/intro-modbus/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/03/introduction/intro-modbus/th.jpg" alt="modbus-logo"></p><h3><span id="modbus历史">Modbus历史</span></h3><p><strong>Modbus协议</strong>最早由Modicon公司（现为施耐德电气公司的品牌）于1979年开发，旨在实现可编程控制器(PLC)之间的通信，后逐渐被大多数公司认可，成为事实上的标准协议，是<strong>全球第一个真正用于工业现场的总线协议</strong>。<br>该公司后来还推出增强型Modbusplus(MB+)协议，完整定义了通信协议、网络结构、线缆等，是典型的令牌环网，与Modbus差异较大。<br>2004年起施耐德电气已将Modbus协议的所有权移交并成立了<strong><a href="http://modbus.org/" target="_blank" rel="noopener">Modbus组织</a></strong>，为之后的发展奠定了基础。在中国，Modbus已经成为国家标准GB/T19582-2008。</p><h3><span id="modbus概述">Modbus概述</span></h3><p>Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型，协议本身没有定义物理层，只是定义了消息帧格式、描述了设备请求和返回数据的过程以及侦测错误的手段等。在现实使用中，可以通过网关将串行链路(RS232/RS485)和以太网等不同物理连接网络通过Modbus协议组成统一的系统。<br><img src="/2018/05/03/introduction/intro-modbus/tcp-structure.JPG" alt="modbus-unified"></p><p><strong>Modbus协议栈</strong>主要包括<a href="http://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf" target="_blank" rel="noopener">Modbus应用层协议</a>、<a href="http://modbus.org/docs/Modbus_over_serial_line_V1_02.pdf" target="_blank" rel="noopener">Modbus串行链路协议</a>和<a href="http://modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf" target="_blank" rel="noopener">Modbus在以太网上的映射</a>，相应的规范可点击链接下载。<br><img src="/2018/05/03/introduction/intro-modbus/stack2.JPG" alt="modbus-stack"></p><h3><span id="modbus应用层协议">Modbus应用层协议</span></h3><p>Modbus应用层协议(OSI L7)规定了与下层实现无关的<strong>协议数据单元</strong>(Protocol Data Unit, PDU)，Modbus协议在某种总线或网络上的映射定义了<strong>应用数据单元</strong>(Application Data Unit, ADU)。不论是Modbus串行链路协议、以太网协议还是其他由Modbus衍生的协议，协议数据单元PDU都由<strong>功能代码段</strong>和<strong>数据段</strong>组成，数据段可以不存在。<br><img src="/2018/05/03/introduction/intro-modbus/general-pdu.JPG" alt="modbus-pdu"></p><h4><span id="请求回应模型">请求——回应模型</span></h4><p>在上层协议中，发出请求的一方为客户端Client，响应的一方为服务端Server。<br>在客户端发出请求消息中，功能代码告知服务端要执行何种功能。数据段包含了服务端要执行功能的任何附加信息。<br>如果服务端产生正常的回应，则返回相同的功能代码给客户端，数据段包括了服务端收集的数据；如果有错误发生，服务端将功能代码的MSB置1返回给客户端，同时数据段包含了描述此错误信息的代码。</p><h4><span id="数据编码和类型">数据编码和类型</span></h4><p>采用<strong>高字节序</strong>(Big-Endian)，即高字节先发送、低字节后发送。<br>Modbus协议中只有两种数据类型，即位bit和字word(16-bit)，根据访问类型分为以下四种：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">访问</th><th style="text-align:left">内容</th></tr></thead><tbody><tr><td style="text-align:center">离散量输入(Discrete Input)</td><td style="text-align:center">位bit</td><td style="text-align:center">只读</td><td style="text-align:left">IO系统提供这种类型数据</td></tr><tr><td style="text-align:center">线圈(Coil)</td><td style="text-align:center">位bit</td><td style="text-align:center">读写</td><td style="text-align:left">通过应用程序改变这种类型数据</td></tr><tr><td style="text-align:center">输入寄存器(Input Register)</td><td style="text-align:center">字word</td><td style="text-align:center">只读</td><td style="text-align:left">IO系统提供这种类型数据</td></tr><tr><td style="text-align:center">保持寄存器(Holding Register)</td><td style="text-align:center">字word</td><td style="text-align:center">读写</td><td style="text-align:left">通过应用程序改变这种类型数据</td></tr></tbody></table><p>地址寻址从0开始，详细的设备地址映射参见具体设备手册。</p><h4><span id="功能代码">功能代码</span></h4><p>功能代码段占用1个字节，取值范围为1-255，其中128-255为保留值，用于异常消息应答报文（原功能代码MSB置1）；1-127为功能代码编号，其中65-72和100-110为用户自定义功能代码，其余取值为通用功能代码。<strong>通用功能代码</strong>(Public Function Code)是已经公布的功能代码，由确定的功能，用户不能修改。<br>常用的通用功能代码如下：<br><img src="/2018/05/03/introduction/intro-modbus/pfc.JPG" alt="modbus-func-code">详细用法见<a href="http://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf" target="_blank" rel="noopener">Modbus应用层协议</a>。</p><h3><span id="modbus串行链路协议">Modbus串行链路协议</span></h3><p>Modbus针对串行链路的协议规定了通信的物理层和数据链路层(OSI L1/2)。物理层采用多种物理接口，最常用的是EIA/TIA-485双线接口。</p><h4><span id="主从模式">主从模式</span></h4><p>数据链路层采用<strong>主从通信模式(Master/Slave)</strong>，只有一个主设备可以初始化通信，并对总线上所有从设备进行控制。</p><ul><li>所有通信由主设备发出，从设备只能对主设备进行响应，互相不允许直接通信。</li><li>主设备对应上层协议中的客户端，从设备对应上层协议中的服务端。</li></ul><p>在<strong>单播模式</strong>(Unicast Mode)中，主设备发送请求至某个特定的从设备，从设备接到请求后进行应答并把消息反馈给主设备；在<strong>广播模式</strong>(Broadcast Mode)中，主设备可同时向多个从设备发送请求（设备地址0），从设备对广播请求不进行响应。<br>对于串行链路，应用数据单元ADU最大长度为256字节，协议数据单元PDU最大长度为253字节。<br>由于主站一次只能读取一个从站的数据，Modbus通信采用轮询方式，用在实时性要求较低的场合。</p><h4><span id="报文格式">报文格式</span></h4><p>串行链路的通用Modbus报文（消息帧）形式如下：<br><img src="/2018/05/03/introduction/intro-modbus/g1.JPG" alt="modbus-frame"><br><strong>1. Modbus-RTU</strong></p><ul><li>该模式中直接发送二进制数据流，以至少3.5个字符时间的停顿间隔分隔两帧，作为两帧开始和终止的标志，整个消息帧必须为连续的传输流，同一帧的两个数据间隔不能超过1.5个字符时间</li><li>在传输过程中需要定时器，从设备不断侦测总线及停顿间隔，当第一个域（即地址域）接收到，每个从设备都进行解码以判断是否发给自己</li><li>数据校验采用CRC（循环冗余校验），详见<a href="/2018/05/14/knowledge/know-crc/" title="CRC循环冗余校验码">CRC循环冗余校验码</a></li><li>地址域1个字节，功能代码1个字节，CRC校验2个字节，数据至多为252字节</li></ul><p><strong>2. Modbus-ASCII</strong></p><ul><li>该模式中消息的每个字节用16进制表示0x00-0xff，转化为两个ASCII字符进行发送，可以使用的传输字符是0-9、A-F，消息帧以字符”:”(ASCII码3A)作为起始符，以回车换行符(ASCII码0D,0A)作为终止符，同一帧的两个数据间隔可至多达到1s</li><li>在传输过程中不需要定时器，从设备不断侦测”:”字符，当接收到时每个设备都解码下个域（即地址域）来判断是否发给自己</li><li>数据校验采用LRC（纵向冗余校验），检测消息帧中除了开始符和终止符外的内容</li><li>起始符1个字节，地址域2个字节，功能代码2个字节，LRC校验2个字节，终止符2个字节，数据至多为2*252字节</li><li>该模式也称为命令行模式，由于发送的是可视化字符串，调试简便，但该模式传输效率较低</li></ul><h3><span id="modbus以太网协议">Modbus以太网协议</span></h3><p>基于Modbus协议进行以太网传输有多种形式，官方文档中给出的是基于Ethernet TCP/IP的Modbus TCP/IP（即Modbus-TCP），定义了TCP传输的报文格式以及<strong>默认端口号502</strong>。除此之外还有Modbus over TCP/IP（将Modbus-RTU/ASCII报文作为TCP数据包）、Modbus UDP/IP、Modbus over UDP/IP等非标准变体。</p><h4><span id="modbus-tcp报文格式">Modbus-TCP报文格式</span></h4><p>Modbus-TCP报文（消息帧）形式如下：<br><img src="/2018/05/03/introduction/intro-modbus/g3.JPG" alt="modbus-frame">数据以类似Modbus-RTU的二进制数据流发送。由于Ethernet TCP/IP数据链路层的校验机制保证了数据的完整性，报文中不含有数据校验，也没有地址域。同时Modbus-TCP加入了4个域、7个字节的报文头来识别应用数据单元ADU，称为<strong>MBAP报文头</strong>(Modbus Application Protoco Header)，具体形式如下：<br><img src="/2018/05/03/introduction/intro-modbus/MBAP_header.JPG" alt="modbus-tcp-header"></p><ol><li>事务处理标识符：用于事务处理配对，在响应中服务端复制请求的事务处理标识符</li><li>协议标识符：用于系统内多路复用，通过值0识别Modbus协议</li><li>长度：单元标识符和PDU的长度</li><li>单元标识符：用于以太网和串行链路间的网关对串行链路从站的通信</li></ol><h4><span id="modbus-rtps">Modbus-RTPS</span></h4><p>To be continued…</p><p>More <a href="http://www.modbustools.com/" target="_blank" rel="noopener">Modbus库和仿真软件</a></p>]]></content>
      
      <categories>
          
          <category> introduction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> industrial network </tag>
            
            <tag> field bus </tag>
            
            <tag> protocol </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DNS域名系统与localhost</title>
      <link href="/2018/05/03/knowledge/know-DNS&amp;localhost/"/>
      <url>/2018/05/03/knowledge/know-DNS&amp;localhost/</url>
      <content type="html"><![CDATA[<p><strong>DNS(Domain Name System，域名系统)</strong>在万维网上作为域名和IP地址相互映射的分布式数据库。通过域名得到对应IP地址的过程叫做<strong>域名解析</strong>。DNS协议运行在UDP协议之上，使用UDP端口号53。为保证服务的高可用性，DNS要求使用多台名称服务器冗余支持每个区域。</p><p>Reference <a href="https://baike.baidu.com/item/DNS/427444#reference-[4]-15346050-wrap" target="_blank" rel="noopener">百度百科</a></p><p><strong>localhost</strong>是一个域名，在windows中该域名是由/etc/hosts文件预定义的，默认对于ipv4指向127.0.0.1，对于ipv6指向::1，可对hosts文件进行修改配置为任意的IP地址，但可能导致只认127.0.0.1的软件失效。</p><p>127.0.0.1/8整个都是环回(loopback)地址，用来测试本机的TCP/IP协议栈，以及本机中各个应用之间的网络交互，也称虚拟网卡。Windows中看不到这个接口，Linux中这个接口叫lo，可通过ifconfig查看。</p><p>本机IP地址一般指绑定在物理或虚拟接口上的IP地址，供其他设备访问。</p><p>Reference <a href="https://www.zhihu.com/question/23940717" target="_blank" rel="noopener">知乎：localhost、127.0.0.1 和 本机IP 三者的区别?</a></p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network basis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NTP网络时间协议</title>
      <link href="/2018/04/28/knowledge/know-NTP/"/>
      <url>/2018/04/28/knowledge/know-NTP/</url>
      <content type="html"><![CDATA[<p><strong>NTP(Network Time Protocol，网络时间协议)</strong>是用来同步网络中各个计算机时间的协议，属于应用层协议，采用UDP报文传输，使用UDP端口号为123。连接到互联网上的主机通过NTP与UTC(Universal Time Coordinate，世界协调时)同步，UTC由原子钟报时。<br>计算机主机一般同多个时钟服务器连接，利用统计学的算法过滤来自不同服务器的时间，选择最佳的路径和来源以便校正主机时间。</p><p>Reference <a href="https://baike.baidu.com/item/nTP" target="_blank" rel="noopener">百度百科NTP词条</a><br>More <a href="http://blog.163.com/yzc_5001/blog/static/2061963420121283050787/" target="_blank" rel="noopener">NTP协议</a></p>]]></content>
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protocol </tag>
            
            <tag> network basis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>修改虚拟机启动时间</title>
      <link href="/2018/04/28/tip/tip-vm-time/"/>
      <url>/2018/04/28/tip/tip-vm-time/</url>
      <content type="html"><![CDATA[<p>由于软件license的时间限制，需要用过去的时间启动虚拟机。</p><ol><li>修改主机时间。启动虚拟机后系统时间即当前主机时间。但在主机中打开Chrome浏览器会报错，提示时钟慢了，无法建立私密连接。</li><li>修改虚拟机启动时间。用文本编辑器打开虚拟机.vmx文件，寻找以下设置项并关闭同步，设置虚拟机启动时间，保存后启动虚拟机。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tools.syncTime = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.continue = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.restore = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.resume.disk = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.shrink = &quot;FALSE&quot;  </span><br><span class="line">time.synchronize.tools.startup = &quot;FALSE&quot; </span><br><span class="line">rtc.startTime = 1462003200</span><br></pre></td></tr></table></figure></li></ol><p>注：rtc.startTime是从1970年1月1日0时0分0秒（Unix时间）到系统启动时间间隔的时间，单位是秒，可以到<a href="http://www.onlineconversion.com/unix_time.htm" target="_blank" rel="noopener">计算时间的网站</a>上换算得到希望虚拟机的启动时间。</p><p>Reference <a href="https://blog.csdn.net/sagafive/article/details/53031740" target="_blank" rel="noopener">VMware12.0 设定虚拟机时间</a></p>]]></content>
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual machine </tag>
            
            <tag> VMWare </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>___C#编写OPC程序</title>
      <link href="/2018/04/28/experience/exp-cs-opc/"/>
      <url>/2018/04/28/experience/exp-cs-opc/</url>
      <content type="html"><![CDATA[<p><a href="https://opcfoundation.org/" target="_blank" rel="noopener">OPC基金会官网</a>真是弱爆了。</p><h3><span id="1-配置opcdaautodll">1. 配置OPCDAAuto.dll</span></h3><p>OPC的自动化接口即OPCDAAuto.dll<br>1)下载文件OPCDAAuto.dll，版本2.2.5.30<br>2)放到System32文件夹下，用管理员身份打开cmd<br>3)输入regsvr32 opcdaauto.dll后提示成功<br>4)打开Visual Studio在项目中打开相应项目，对解决方案右键-添加-引用，浏览选择opcdaaturo.dll<br>5)依赖项中出现COM-Interop.OPCAutomation，在C#程序开头using OPCAutomation；不再显示红色波浪线错误，即配置成功。</p><p>Reference <a href="https://blog.csdn.net/u012252959/article/details/49699559" target="_blank" rel="noopener">u012252959的博客</a></p><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> experience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OPC </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Learning hard C#学习笔记》笔记</title>
      <link href="/2018/04/28/note/note-cs/"/>
      <url>/2018/04/28/note/note-cs/</url>
      <content type="html"><![CDATA[<p>《Learning hard C#学习笔记》 李志 人民邮电出版社<br><a id="more"></a></p><!-- toc --><ul><li><a href="#第一章-基础知识">第一章 基础知识</a></li><li><a href="#第八章-委托">第八章 委托</a></li><li><a href="#第九章-事件">第九章 事件</a></li></ul><!-- tocstop --><h2><span id="第一章-基础知识">第一章 基础知识</span></h2><p>C#</p><h2><span id="第八章-委托">第八章 委托</span></h2><p><strong>委托</strong>是C#中最中需要的特性之一，它使得C#中的函数可以作为参数被传递，与C/C++中的函数指针类似。它是一个特殊的类，所有的委托都是从System.MulticastDelegate类派生的。<br>委托的定义和方法的定义类似，只是在定义前多了一个delegate关键字：</p><pre><code>访问修饰符 delegate 返回类型 委托名([参数表])</code></pre><p>能被委托包装的方法需要满足：</p><ol><li>方法的签名与委托一致（参数个数、类型、顺序）</li><li>方法的返回类型与委托一致</li></ol><p>委托也可以封装多个方法，称为<strong>委托链</strong>或多路广播委托，在委托链上的委托都会被顺序执行。可以通过“+”运算符把委托链接到一个委托对象实例上，也可以使用“-”运算符将某个委托从委托链对象上移除。</p><div><div class="fold_hider"><div class="close hider_title">委托和委托链的例子（点击显示代码）</div></div><div class="fold"><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSbook</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//委托的定义</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params">MyDelegate mydelegate</span>)</span>&#123;</span><br><span class="line">            mydelegate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            MyDelegate m = <span class="keyword">new</span> MyDelegate(Program.Mult);</span><br><span class="line">            <span class="comment">// 方法Program.Mult作为方法MyMethod的参数</span></span><br><span class="line">            MyMethod(m);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            MyDelegate p = <span class="keyword">new</span> MyDelegate(<span class="keyword">new</span> Program().Add);</span><br><span class="line">            MyDelegate q = <span class="keyword">new</span> MyDelegate(<span class="keyword">new</span> Program().Sub);</span><br><span class="line">            MyDelegate chain = <span class="literal">null</span>;</span><br><span class="line">            chain += m;</span><br><span class="line">            chain += p;</span><br><span class="line">            chain += q;</span><br><span class="line">            chain -= m;</span><br><span class="line">            chain(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实例方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = para1 + para2;</span><br><span class="line">            Console.WriteLine(<span class="string">"Sum is: "</span> + sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Sub</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sub = para1 - para2;</span><br><span class="line">            Console.WriteLine(<span class="string">"Sub is: "</span> + sub);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mult</span>(<span class="params"><span class="keyword">int</span> para1, <span class="keyword">int</span> para2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mul = para1 * para2;</span><br><span class="line">            Console.WriteLine(<span class="string">"Mul is: "</span> + mul);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2><span id="第九章-事件">第九章 事件</span></h2><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>___FactoryTalk Transaction Manager使用心得</title>
      <link href="/2018/04/27/experience/exp-trans-1/"/>
      <url>/2018/04/27/experience/exp-trans-1/</url>
      <content type="html"><![CDATA[<h2><span id="基本概念">基本概念</span></h2><p><strong>FactoryTalk Transaction Manager</strong>（前身RSSql）是Rockwell公司FactoryTalk系列组态软件之一，主要实现工控系统与数据库的通信，该系列软件基于<a href="https://baike.baidu.com/item/SOA/2140650" target="_blank" rel="noopener">SOA架构</a>开发，因此Transaction Manager的应用软件部分实际上是对各个数据传送的Windows服务进行配置的UI界面(Configuration User Interface)，该软件的核心实际上是各个接口的服务程序。<br><a id="more"></a></p><p><img src="/2018/04/27/experience/exp-trans-1/structure.JPG" alt="structure"></p><p>Transaction and Control Manager服务包含了Transaction Manager Service服务和FactoryTalk Live Data控制接口，可以通过该服务连接Rockwell软件和所有OPC服务器。启动操作系统后查看服务列表，可以看到Transaction Manager相关的各个服务。</p><p><img src="/2018/04/27/experience/exp-trans-1/services.png" alt="services"></p><p>FactoryTalk Transaction Manager可以使用以下<strong>控制接口</strong>(Control Connector)，来关联数据点(data point)或存储地址(memory location)：</p><ol><li><strong>FactoryTalk Live Data</strong></li><li>Dynamic Data Exchange (DDE)</li><li>RSLinx Classic OPC</li><li>RSView32</li><li><strong>Generic OPC</strong></li></ol><p>FactoryTalk Transaction Manager可以使用以下<strong>企业接口</strong>(Enterprise Connector)，来创建数据对象(data object)与企业系统中的数据表(database table)和预存过程(stored procedure)进行交互：</p><ol><li>Open Database Connectivity (ODBC)</li><li><strong>Microsoft OLE DB</strong></li><li>Microsoft COM+</li><li><strong>Oracle Call Interface (OCI)</strong></li><li>Time-series Data Compression</li><li>FactoryTalk Metrics connector</li></ol><h2><span id="配置过程">配置过程</span></h2><p>###<br>&lt;!– ## 1. OPC Server -&gt; SQL Server ##</p><p>OPC Server: KEPSever Enterprise 5.13<br>SQL Server: Microsoft SQL Server 2008 R2</p><h2><span id="2-live-data-gt-sql-server">2. Live Data -&gt; SQL Server</span></h2><h2><span id="3-sql-server-gt-live-data-gt">3. SQL Server -&gt; Live Data –&gt;</span></h2><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> experience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OPC </tag>
            
            <tag> FactoryTalk </tag>
            
            <tag> Rockwell </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《OPC应用程序入门》笔记</title>
      <link href="/2018/04/27/note/note-opc/"/>
      <url>/2018/04/27/note/note-opc/</url>
      <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#第一章-opc基础知识">第一章 OPC基础知识</a><ul><li><a href="#11-什么是opc">1.1 什么是OPC</a></li></ul></li></ul><!-- tocstop --><p>《OPC应用程序入门》<br><a id="more"></a></p><p><img src="/2018/04/27/note/note-opc/ch1-1.PNG" alt="ch1-1"></p><h2><span id="第一章-opc基础知识">第一章 OPC基础知识</span></h2><h3><span id="11-什么是opc">1.1 什么是OPC</span></h3><p><strong>OPC</strong>(OLE for Process Control)是为不同供应商设备和应用程序之间的软件接口标准化而提出的，使其间的数据交换不依赖于特定开发语言和开发环境。它利用Windows中的OLE/COM技术实现<strong>工业制造系统过程控制中数据交换的标准化</strong>。OPC系统由提供数据收集服务的<strong>OPC服务器</strong>(OPC Server)、接受数据服务的<strong>OPC应用程序</strong>(OPC Client)和<strong>OPC接口</strong>所构成。</p><p>在OPC技术出现以前，<strong>DDE</strong>（Dynamic Data Exchange）技术曾经对过程控制做出巨大贡献，但是DDE是基于Windows信息传递而建立的技术，存在诸多问题。OPC基于<strong>COM</strong>（组件对象模型，Component Object Model）和<strong>DCOM</strong>（分布式COM）技术开发，实际上OPC是为工业标准定义的特殊的COM接口，与DDE相比在速度、分布式安全管理、开发成本、可靠性等方面都具有优势。</p><p>—-To Be Continued—-</p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OPC </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
